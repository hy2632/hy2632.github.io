<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hy2632.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Summary short rate 的二叉树模型，假设 q-martingale 的概率是 0.5&#x2F;0.5。  在利率二叉树中，利率上升与下跌的概率是相同的；而在股票二叉树模型中，上涨下跌是由 u d 计算而得。之所以假设利率二叉树上升下降概率相同是因为利率由均值复归的特性。  利率二叉树和yield curve是对应的。如果使用BDT或Ho-Lee这样的二叉树，需要对参数进行校准。 从无息债券">
<meta property="og:type" content="article">
<meta property="og:title" content="IEOR E4706: Term Structure Lattice Models">
<meta property="og:url" content="https://hy2632.github.io/2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/index.html">
<meta property="og:site_name" content="豁蒙楼">
<meta property="og:description" content="Summary short rate 的二叉树模型，假设 q-martingale 的概率是 0.5&#x2F;0.5。  在利率二叉树中，利率上升与下跌的概率是相同的；而在股票二叉树模型中，上涨下跌是由 u d 计算而得。之所以假设利率二叉树上升下降概率相同是因为利率由均值复归的特性。  利率二叉树和yield curve是对应的。如果使用BDT或Ho-Lee这样的二叉树，需要对参数进行校准。 从无息债券">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-26T22:05:57.000Z">
<meta property="article:modified_time" content="2021-03-23T13:53:02.969Z">
<meta property="article:author" content="姚华(Hua Yao)">
<meta property="article:tag" content="Financial Engineering">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hy2632.github.io/2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>IEOR E4706: Term Structure Lattice Models | 豁蒙楼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">豁蒙楼</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/hy2632" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hy2632.github.io/2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/54726816?s=460&u=39a4b895b570f1c0a114d932d9eff85d49cbe399&v=4">
      <meta itemprop="name" content="姚华(Hua Yao)">
      <meta itemprop="description" content="hy2632@columbia.edu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="豁蒙楼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          IEOR E4706: Term Structure Lattice Models
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-26 17:05:57" itemprop="dateCreated datePublished" datetime="2021-02-26T17:05:57-05:00">2021-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-23 08:53:02" itemprop="dateModified" datetime="2021-03-23T08:53:02-05:00">2021-03-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Finance/" itemprop="url" rel="index"><span itemprop="name">Finance</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="summary">Summary</h2>
<p>short rate 的二叉树模型，假设 q-martingale 的概率是 0.5/0.5。</p>
<blockquote>
<p>在利率二叉树中，利率上升与下跌的概率是相同的；而在股票二叉树模型中，上涨下跌是由 u d 计算而得。之所以假设利率二叉树上升下降概率相同是因为利率由均值复归的特性。</p>
</blockquote>
<p>利率二叉树和yield curve是对应的。如果使用BDT或Ho-Lee这样的二叉树，需要对参数进行校准。</p>
<p>从无息债券定价的 backward evaluation 开始，回溯法是通用的方法；在此基础上以债券为标的的衍生品的定价...</p>
<p>如果衍生品不能提前行权，也可先计算行权日状态价格再直接定价。</p>
<h2 id="二叉树模型">二叉树模型</h2>
<p>从短期利率的二叉树模型开始。</p>
<h3 id="构造一个无套利的二叉树">构造一个无套利的二叉树</h3>
<p><span class="math inline">\(r_{i,j}\)</span> : 时间 i 状态 j 下的短期利率。</p>
<p>鞅定价：</p>
<p><span class="math display">\[S_i(j) = \frac1{1+r_{i,j}} [q_uS_{i+1}(j+1) + q_d S_{i+1}(j)] + \text{dividend}\]</span></p>
<p><span class="math inline">\(q\)</span> 是与鞅对应的测度。</p>
<h3 id="从二叉树到利率期限结构">从二叉树到利率期限结构</h3>
<blockquote>
<p>例1：short rate 的二叉树 r 给出；为无息债券定价：T=4, F=100, q=0。</p>
<p>backward evaluation 得出 bond lattice，发现其 t=0 时刻价格为 77.22。从而计算出四年利率 <span class="math inline">\(s_4\)</span>。如果有短期利率，就可以推导出利率期限结构。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Params</span></span><br><span class="line">T=<span class="number">4</span></span><br><span class="line">F=<span class="number">100</span></span><br><span class="line">q=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">shortRateLattice = np.ones((T+<span class="number">1</span>, T+<span class="number">1</span>)) * np.nan</span><br><span class="line">shortRateLattice[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">0.06</span></span><br><span class="line">u=<span class="number">1.25</span></span><br><span class="line">d=<span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, T+<span class="number">1</span>):</span><br><span class="line">    shortRateLattice[t, <span class="number">0</span>] = shortRateLattice[t<span class="number">-1</span>, <span class="number">0</span>] * d</span><br><span class="line">    shortRateLattice[t, <span class="number">1</span>:t+<span class="number">1</span>] = shortRateLattice[t<span class="number">-1</span>, :t] * u</span><br><span class="line">shortRateLattice.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>([[<span class="number">0.06</span> ,   nan,   nan,   nan,   nan],</span><br><span class="line">       [<span class="number">0.054</span>, <span class="number">0.075</span>,   nan,   nan,   nan],</span><br><span class="line">       [<span class="number">0.049</span>, <span class="number">0.068</span>, <span class="number">0.094</span>,   nan,   nan],</span><br><span class="line">       [<span class="number">0.044</span>, <span class="number">0.061</span>, <span class="number">0.084</span>, <span class="number">0.117</span>,   nan],</span><br><span class="line">       [<span class="number">0.039</span>, <span class="number">0.055</span>, <span class="number">0.076</span>, <span class="number">0.105</span>, <span class="number">0.146</span>]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Q-martingale&#x27;s probability</span></span><br><span class="line">qu = <span class="number">0.5</span></span><br><span class="line">qd = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">bondLattice = np.ones_like(shortRateLattice) * np.nan</span><br><span class="line"></span><br><span class="line">bondLattice[<span class="number">-1</span>] = F</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(T<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    bondLattice[t, :t+<span class="number">1</span>] = (bondLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>] * qd + bondLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] * qu) / (<span class="number">1</span>+shortRateLattice[t, :t+<span class="number">1</span>]) +q*F</span><br><span class="line">bondLattice.round(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>([[ <span class="number">77.22</span>,    nan,    nan,    nan,    nan],</span><br><span class="line">       [ <span class="number">84.43</span>,  <span class="number">79.27</span>,    nan,    nan,    nan],</span><br><span class="line">       [ <span class="number">90.64</span>,  <span class="number">87.35</span>,  <span class="number">83.08</span>,    nan,    nan],</span><br><span class="line">       [ <span class="number">95.81</span>,  <span class="number">94.27</span>,  <span class="number">92.22</span>,  <span class="number">89.51</span>,    nan],</span><br><span class="line">       [<span class="number">100.</span>  , <span class="number">100.</span>  , <span class="number">100.</span>  , <span class="number">100.</span>  , <span class="number">100.</span>  ]])</span><br></pre></td></tr></table></figure>
<h3 id="利率衍生品定价">利率衍生品定价</h3>
<h4 id="债券的期权">债券的期权</h4>
<blockquote>
<p>例2：4年到期无息债券 的 <strong>european call</strong> (2年到期, K=84)</p>
<p>首先推导出 bond lattice，然后 t=2 期权价值 <span class="math inline">\(C = \max{(S-K, 0)}\)</span>。由于是欧式期权，仅能在 t=2 行权，所以根据 option lattice 的 t=2 回溯即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># European Call option on the bond</span></span><br><span class="line">tau = <span class="number">2</span></span><br><span class="line">K = <span class="number">84</span></span><br><span class="line"></span><br><span class="line">eurocallLattice = np.zeros((tau+<span class="number">1</span>, tau+<span class="number">1</span>)) * np.nan</span><br><span class="line">eurocallLattice[<span class="number">-1</span>] = np.clip(bondLattice[tau, :eurocallLattice[<span class="number">-1</span>].shape[<span class="number">0</span>]] - K, <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(tau<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    eurocallLattice[t,:t+<span class="number">1</span>] = (eurocallLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] * qu + eurocallLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>] * qd) / (<span class="number">1</span> + shortRateLattice[t, :t+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">eurocallLattice.round(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>([[<span class="number">2.97</span>,  nan,  nan],</span><br><span class="line">       [<span class="number">4.74</span>, <span class="number">1.56</span>,  nan],</span><br><span class="line">       [<span class="number">6.64</span>, <span class="number">3.35</span>, <span class="number">0.</span>  ]])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例3: 还是上例的条件，换成<strong>美式看跌</strong></p>
<p>美式看跌可以提前行权，所以在回溯之前的每个节点时，需要比较 bond lattice 对应节点的行权收益 (exercise value) 和折算的收益 (continuation value)。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># American Put on the bond</span></span><br><span class="line">K_ = <span class="number">88</span></span><br><span class="line">ameputLattice = np.zeros_like(eurocallLattice) * np.nan</span><br><span class="line">ameputLattice[<span class="number">-1</span>] = np.clip(K_-bondLattice[tau, :tau+<span class="number">1</span>], <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(tau<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    continuation_value = (ameputLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] * qu + ameputLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>] * qd) / (<span class="number">1</span> + shortRateLattice[t, :t+<span class="number">1</span>])</span><br><span class="line">    exercise_value = np.clip(K_-bondLattice[t, :t+<span class="number">1</span>], <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">    ameputLattice[t, :t+<span class="number">1</span>] = np.max(np.vstack([continuation_value, exercise_value]), axis=<span class="number">0</span>)</span><br><span class="line">ameputLattice.round(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>([[<span class="number">10.78</span>,   nan,   nan],</span><br><span class="line">       [ <span class="number">3.57</span>,  <span class="number">8.73</span>,   nan],</span><br><span class="line">       [ <span class="number">0.</span>  ,  <span class="number">0.65</span>,  <span class="number">4.92</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="债券的期货">债券的期货</h4>
<p>假设完备市场 (任何证券都能够被唯一地定价；不完备时，如果某证券能够被复制，则也能被定价)，根据鞅定价理论</p>
<p><span class="math display">\[ 0= E_{n-1}^Q \left[ \frac{F_n - F_{n-1}}{B_n}  \right]\]</span></p>
<p><span class="math display">\[F_{n-1} = E_{n-1}^Q \left[ F_n \right]\]</span></p>
<p>又，在到期日</p>
<p><span class="math display">\[F_n = S_n\]</span></p>
<p>重期望公式 iterated expectation</p>
<p><span class="math display">\[F_0 = E_0^Q [S_n]\]</span></p>
<p>如果债券含息，上式依然成立，但需要把 <span class="math inline">\(S_n\)</span> 去息。二叉树回溯时做处理。</p>
<h4 id="债券的远期">债券的远期</h4>
<p>远期和期货最大的区别是逐日盯市和保证金。</p>
<p><span class="math display">\[ 0 = E_0^Q \left[ \frac{S_n - G_0}{B_n}  \right]\]</span></p>
<p><span class="math display">\[G_0 = \frac{E_0^Q\left[\frac{S_n}{B_n}\right]}{E_0^Q\left[\frac{1}{B_n}\right]}\]</span></p>
<p>在上一章 <a href="https://hy2632.github.io/2021/02/15/IEOR-E4706-Martingale-Pricing-Theory-Discrete-Time-Space/">鞅定价</a> 提及远期和期货的价格关系，标的和利率正相关时，期货价格更高。</p>
<p>债券不付息时，</p>
<p><span class="math display">\[G_0 = \frac{S_0}{E_0^Q\left[\frac{1}{B_n}\right]} = \frac{E_0^Q\left[S_0\right]}{d(0,n)}\]</span></p>
<h4 id="期货和远期的例子">期货和远期的例子</h4>
<blockquote>
<p>例4 含息债券的远期合约定价。 参数：债券6年到期，远期合约 4-6，息率 q=10%，计算该远期合约的价格。短期利率二叉树与之前相同。</p>
<p>这个合约的underlying asset可以看作0-4年不付息，4-6年付息。首先从第六年对含息债券进行回溯，然后按照无息债券继续回溯到 t=0。然后套用远期的定价公式，由于前四年不付息，可以直接套用上式无息债券的远期定价。discounting factor 可以用之前例子中无息债券回溯的结果 <span class="math inline">\(d_4 = 100/77.22\)</span>，也可以通过二项分布的pmf计算期望。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># params</span></span><br><span class="line">t=<span class="number">4</span></span><br><span class="line">tau=<span class="number">2</span></span><br><span class="line">T=t+tau</span><br><span class="line">q=<span class="number">0.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shortRateLattice = np.ones((T+<span class="number">1</span>, T+<span class="number">1</span>)) * np.nan</span><br><span class="line">shortRateLattice[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">0.06</span></span><br><span class="line">u=<span class="number">1.25</span></span><br><span class="line">d=<span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, T+<span class="number">1</span>):</span><br><span class="line">    shortRateLattice[t, <span class="number">0</span>] = shortRateLattice[t<span class="number">-1</span>, <span class="number">0</span>] * d</span><br><span class="line">    shortRateLattice[t, <span class="number">1</span>:t+<span class="number">1</span>] = shortRateLattice[t<span class="number">-1</span>, :t] * u</span><br><span class="line">shortRateLattice.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.06 ,   nan,   nan,   nan,   nan,   nan,   nan],
       [0.054, 0.075,   nan,   nan,   nan,   nan,   nan],
       [0.049, 0.068, 0.094,   nan,   nan,   nan,   nan],
       [0.044, 0.061, 0.084, 0.117,   nan,   nan,   nan],
       [0.039, 0.055, 0.076, 0.105, 0.146,   nan,   nan],
       [0.035, 0.049, 0.068, 0.095, 0.132, 0.183,   nan],
       [0.032, 0.044, 0.062, 0.085, 0.119, 0.165, 0.229]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bondLattice = np.ones_like(shortRateLattice)*np.nan</span><br><span class="line">bondLattice[<span class="number">-1</span>] = <span class="number">110</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> (<span class="number">5</span>,):</span><br><span class="line">    bondLattice[t, :t+<span class="number">1</span>] = (bondLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] * <span class="number">0.5</span> + bondLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]*<span class="number">0.5</span>)/ (<span class="number">1</span>+ shortRateLattice[t, :t+<span class="number">1</span>]) + q*<span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">4</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    bondLattice[t, :t+<span class="number">1</span>] = (bondLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] * <span class="number">0.5</span> + bondLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]*<span class="number">0.5</span>)/ (<span class="number">1</span>+ shortRateLattice[t, :t+<span class="number">1</span>])</span><br><span class="line">bondLattice.round(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 79.83,    nan,    nan,    nan,    nan,    nan,    nan],
       [ 89.24,  79.99,    nan,    nan,    nan,    nan,    nan],
       [ 97.67,  90.45,  81.53,    nan,    nan,    nan,    nan],
       [104.99,  99.85,  93.27,  85.08,    nan,    nan,    nan],
       [111.16, 108.  , 103.83,  98.44,  91.66,    nan,    nan],
       [116.24, 114.84, 112.96, 110.46, 107.19, 102.98,    nan],
       [110.  , 110.  , 110.  , 110.  , 110.  , 110.  , 110.  ]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> spst</span><br><span class="line">spst.binom.pmf(range(<span class="number">5</span>),<span class="number">4</span>, p=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.0625, 0.25  , 0.375 , 0.25  , 0.0625])</code></pre>
<p><span class="math display">\[G_0 = \frac{E_0^Q\left[\frac{S_4}{B_4}\right]}{E_0^Q\left[\frac{1}{B_4}\right]} = S_0/d_4, d_4 = 77.22/100\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numeraire</span></span><br><span class="line">numeraireLattice = np.ones((<span class="number">5</span>,<span class="number">5</span>))*np.nan</span><br><span class="line">numeraireLattice[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    numeraireLattice[t, <span class="number">0</span>] = numeraireLattice[t<span class="number">-1</span>, <span class="number">0</span>] * (shortRateLattice[t, <span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">    numeraireLattice[t, <span class="number">1</span>:t+<span class="number">1</span>] =numeraireLattice[t<span class="number">-1</span>, :t] * (shortRateLattice[t<span class="number">-1</span>, <span class="number">0</span>:t] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numeraireLattice</span><br></pre></td></tr></table></figure>
<pre><code>array([[1.        ,        nan,        nan,        nan,        nan],
       [1.054     , 1.06      ,        nan,        nan,        nan],
       [1.1052244 , 1.110916  , 1.1395    ,        nan,        nan],
       [1.15356692, 1.15893831, 1.18590283, 1.24632813,        nan],
       [1.19897823, 1.20402393, 1.22934381, 1.28596338, 1.3923822 ]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = spst.binom.pmf(range(<span class="number">5</span>),<span class="number">4</span>, p=<span class="number">0.5</span>)</span><br><span class="line">(p*bondLattice[<span class="number">4</span>, :<span class="number">5</span>]/numeraireLattice[<span class="number">4</span>, :<span class="number">5</span>]).mean() / (p/numeraireLattice[<span class="number">4</span>, :<span class="number">5</span>]).mean()</span><br></pre></td></tr></table></figure>
<pre><code>103.39897946734145</code></pre>
<blockquote>
<p>例5 对含息债券的期货合约定价</p>
<p>期货需要关注中间节点，每一个阶段都无套利。因而可以作出期货的二叉树。</p>
<p>期货价格回溯的公式 <span class="math display">\[F_{n-1} = E_{n-1}^Q[F_n]\]</span> 不需要除以计价资产。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">futuresLattice = np.ones((<span class="number">5</span>, <span class="number">5</span>))*np.nan</span><br><span class="line">futuresLattice[<span class="number">-1</span>] = bondLattice[<span class="number">4</span>, :<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    futuresLattice[t, :t+<span class="number">1</span>] = (futuresLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] * <span class="number">0.5</span> + futuresLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>] * <span class="number">0.5</span>) </span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">futuresLattice</span><br></pre></td></tr></table></figure>
<pre><code>array([[103.22201887,          nan,          nan,          nan,
                 nan],
       [105.63552539, 100.80851235,          nan,          nan,
                 nan],
       [107.74653381, 103.52451698,  98.09250772,          nan,
                 nan],
       [109.5799363 , 105.91313132, 101.13590263,  95.0491128 ,
                 nan],
       [111.16255143, 107.99732117, 103.82894147,  98.44286379,
         91.65536181]])</code></pre>
<h4 id="利率上限-caplet-的定价">利率上限 Caplet 的定价</h4>
<p>caplet 简而言之是以利率为标的资产的 european call。</p>
<p>settled in arrears: if maturity is <span class="math inline">\(\tau\)</span> and the strike is <span class="math inline">\(c\)</span> then the payoff at time <span class="math inline">\(\tau\)</span> is <span class="math inline">\((r_{\tau -1} - c)^+\)</span>.</p>
<blockquote>
<p>例6: 为一个 Caplet 定价，基于之前的短期利率树。参数 t=6, c=0.02。</p>
<p>由于 caplet 是european call，不涉及到中间结点的比较，直接根据标的资产的lattice进行计算。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">6</span></span><br><span class="line">c = <span class="number">0.02</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shortRateLattice.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.06 ,   nan,   nan,   nan,   nan,   nan,   nan],
       [0.054, 0.075,   nan,   nan,   nan,   nan,   nan],
       [0.049, 0.068, 0.094,   nan,   nan,   nan,   nan],
       [0.044, 0.061, 0.084, 0.117,   nan,   nan,   nan],
       [0.039, 0.055, 0.076, 0.105, 0.146,   nan,   nan],
       [0.035, 0.049, 0.068, 0.095, 0.132, 0.183,   nan],
       [0.032, 0.044, 0.062, 0.085, 0.119, 0.165, 0.229]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capletLattice = np.ones((<span class="number">6</span>,<span class="number">6</span>)) * np.nan</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    capletLattice[t, :t+<span class="number">1</span>] = (np.clip(shortRateLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>]-c, <span class="number">0</span>, <span class="literal">None</span>) * <span class="number">0.5</span> +  np.clip(shortRateLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]-c, <span class="number">0</span>, <span class="literal">None</span>) * <span class="number">0.5</span>) / (<span class="number">1</span>+shortRateLattice[t, :t+<span class="number">1</span>])</span><br><span class="line">capletLattice.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.042,   nan,   nan,   nan,   nan,   nan],
       [0.036, 0.056,   nan,   nan,   nan,   nan],
       [0.031, 0.049, 0.074,   nan,   nan,   nan],
       [0.026, 0.043, 0.065, 0.095,   nan,   nan],
       [0.021, 0.037, 0.057, 0.084, 0.12 ,   nan],
       [0.017, 0.031, 0.05 , 0.075, 0.108, 0.149]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capletLattice = np.ones((<span class="number">6</span>,<span class="number">6</span>)) * np.nan</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    capletLattice[t, :t+<span class="number">1</span>] = (np.clip(shortRateLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>]-c, <span class="number">0</span>, <span class="literal">None</span>) * <span class="number">0.5</span> /(<span class="number">1</span>+shortRateLattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>]) +  np.clip(shortRateLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]-c, <span class="number">0</span>, <span class="literal">None</span>) * <span class="number">0.5</span> / (<span class="number">1</span>+shortRateLattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]) ) / (<span class="number">1</span>+shortRateLattice[t, :t+<span class="number">1</span>])</span><br><span class="line">capletLattice.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.039,   nan,   nan,   nan,   nan,   nan],
       [0.034, 0.052,   nan,   nan,   nan,   nan],
       [0.029, 0.046, 0.067,   nan,   nan,   nan],
       [0.025, 0.04 , 0.06 , 0.084,   nan,   nan],
       [0.021, 0.035, 0.053, 0.076, 0.103,   nan],
       [0.017, 0.03 , 0.047, 0.068, 0.094, 0.124]])</code></pre>
<hr />
<h2 id="the-forward-equations">The Forward Equations</h2>
<p>定义基本证券 elementary security 或称 Arrow-Debreu / AD-security</p>
<p><span class="math display">\[P_e(i,j)\]</span></p>
<p>为在时间 i 和状态 j 支付 $1 的证券在 0 时刻的价格。又称为状态价格。</p>
<p>前向递推，上一阶段的基本证券到下一个阶段会复利，因而下一阶段的基本证券需要折减。状态价格满足这些 <strong>forward equations</strong>:</p>
<p><span class="math display">\[P_e(k+1, s) = \frac{P_e(k, s-1)}{2(1 + r_{k,s-1})} + \frac{P_e(k, s)}{2(1 + r_{k,s})}, 0&lt;s&lt;k+1\]</span></p>
<p><span class="math display">\[P_e(k+1, 0) = \frac{P_e(k, 0)}{2(1 + r_{k,0})}\]</span></p>
<p><span class="math display">\[P_e(k+1, k+1) = \frac{P_e(k, k)}{2(1 + r_{k,k})}\]</span></p>
<p>计算状态价格并根据状态价格推导期限结构的复杂度是 <span class="math inline">\(O(T^2)\)</span>，而回溯无息债券价格的复杂度是 <span class="math inline">\(O(T^3)\)</span>。需要注意，状态价格定价法只适用于行权日确定的证券。</p>
<h3 id="二叉树中的对冲例7">二叉树中的对冲，例7</h3>
<p>Given a short rate lattice</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short_rate = np.array([</span><br><span class="line">    [<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">5.4</span>, <span class="number">7.8</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">4.86</span>, <span class="number">7.02</span>, <span class="number">10.14</span>]</span><br><span class="line">]) / <span class="number">100</span></span><br></pre></td></tr></table></figure>
<ol type="a">
<li>Compute the elementary prices</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">state_prices</span>(<span class="params">r: np.array</span>):</span></span><br><span class="line">    T = r.shape[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">    Pe = np.zeros((T+<span class="number">1</span>, T+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    Pe[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(T):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">            Pe[k+<span class="number">1</span>, s] = Pe[k, s<span class="number">-1</span>]/(<span class="number">2</span>*(<span class="number">1</span>+r[k, s<span class="number">-1</span>])) + Pe[k,s] / (<span class="number">2</span>*(<span class="number">1</span>+r[k,s]))</span><br><span class="line">        Pe[k+<span class="number">1</span>, <span class="number">0</span>] = Pe[k, <span class="number">0</span>] / (<span class="number">2</span>*(<span class="number">1</span>+r[k,<span class="number">0</span>]))</span><br><span class="line">        Pe[k+<span class="number">1</span>, k+<span class="number">1</span>] = Pe[k,k] / (<span class="number">2</span>*(<span class="number">1</span>+r[k,k]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Pe</span><br><span class="line"></span><br><span class="line">state_prices(short_rate)</span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>([[<span class="number">1.</span>        , <span class="number">0.</span>        , <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.47169811</span>, <span class="number">0.47169811</span>, <span class="number">0.</span>        ],</span><br><span class="line">       [<span class="number">0.22376571</span>, <span class="number">0.44254962</span>, <span class="number">0.21878391</span>]])</span><br></pre></td></tr></table></figure>
<ol start="2" type="a">
<li>Given a different short rate lattice &amp; elementary prices. Find the prices of a zero-coupon bond with face value $100 that matures at t=3</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r = np.array([</span><br><span class="line">    [<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">5.4</span>, <span class="number">7.2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">4.86</span>, <span class="number">6.48</span>, <span class="number">8.64</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">4.37</span>, <span class="number">5.83</span>, <span class="number">7.78</span>, <span class="number">10.37</span>],</span><br><span class="line">]) /<span class="number">100</span></span><br><span class="line"></span><br><span class="line">Pe = np.array([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.4717</span>, <span class="number">0.4717</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.2238</span>, <span class="number">0.4438</span>, <span class="number">0.22</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0.1067</span>, <span class="number">0.3151</span>, <span class="number">0.3096</span>, <span class="number">0.1013</span>],</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sum(Pe[<span class="number">3</span>])*<span class="number">100</span></span><br></pre></td></tr></table></figure>
<pre><code>83.27</code></pre>
<ol start="3" type="a">
<li>Compute the price of a Euro-call on the zero coupon bond of (b) with K=$93 and expiration t=2</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Payoff in different states at t=2</span></span><br><span class="line"><span class="comment"># backward from t=3 to t=2</span></span><br><span class="line">payoff = (<span class="number">100</span> / (<span class="number">1</span>+r[<span class="number">2</span>]) [:<span class="number">3</span>] - <span class="number">93</span>).clip(min=<span class="number">0</span>)</span><br><span class="line">payoff</span><br></pre></td></tr></table></figure>
<pre><code>array([2.3652489 , 0.91435011, 0.        ])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.dot(payoff, Pe[<span class="number">2</span>,:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<pre><code>0.935131284573487</code></pre>
<ol start="4" type="a">
<li>Immunize the obligation of value today $100 and (1,1) value of $95 using date 1 elementary securities.</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">117</span>+<span class="number">95</span>)*<span class="number">0.4717</span></span><br></pre></td></tr></table></figure>
<pre><code>100.0004</code></pre>
<p>PS: 根据鞅定价理论，该组合在 t=1 时的价值折现到 t=0 也是 100。</p>
<p><span class="math display">\[100 = \frac12 \frac{95}{1.06} + \frac12 \frac{x}{1.06}\]</span></p>
<p>或者按照状态价格，</p>
<p><span class="math display">\[0.4717 x + 0.4717 \times 95 = 100\]</span></p>
<p>状态价格本身就包含了折现，用于确定现在的价格。</p>
<ol start="5" type="a">
<li>Compute the value of the forward swap that begins at t=1 and ends at t=3. Notional principal $1. Fixed rate of the swap is 5%. Payments at t=i (i=1,2,3) are based on the fixed rate minus the floating rate that prevailed at t=i-1.</li>
</ol>
<p>第 i 个时间点上，持有 swap 的 PNL 实际上可以折算到第 i-1 个时间点上。t = 2,3 的swap 实际上看 t=1,2 的各个节点。swap可以看成是一系列单阶段。</p>
<p><span class="math display">\[(r_{i,j} - 0.05) \times P_e(i,j) / (1+r_{i, j})\]</span></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_ = np.where(r==<span class="number">0</span>, np.nan, r)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pe_ = np.where(Pe==<span class="number">0</span>, np.nan, Pe)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap_lattice = (Pe[:<span class="number">3</span>] * (r_[:<span class="number">3</span>] - <span class="number">0.05</span>) / (<span class="number">1</span>+r_[:<span class="number">3</span>]))</span><br><span class="line">swap_lattice</span><br></pre></td></tr></table></figure>
<pre><code>array([[ 0.00943396,         nan,         nan,         nan],
       [ 0.00179013,  0.00968041,         nan,         nan],
       [-0.0002988 ,  0.00616852,  0.00737113,         nan]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.nansum(swap_lattice[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<pre><code>0.024711398807682642</code></pre>
<hr />
<h2 id="some-specific-models">Some specific models</h2>
<p>需要对 lattice 进行调整，使得期限结构（无息债券价格）或利率波动性等与市场匹配。使用两种模型可以实现。</p>
<h3 id="the-ho-lee-model">The Ho-Lee Model</h3>
<p>short rate 满足</p>
<p><span class="math display">\[r_{i,j} = a_i + b_i j\]</span></p>
<p>漂移项+波动率放大系数。<span class="math inline">\(N(i,j)\)</span> 处的标准差是 <span class="math inline">\(b_i/2\)</span>。 （？）</p>
<p>连续时间</p>
<p><span class="math display">\[dr_t = \mu_tdt + \sigma_tdW_t\]</span></p>
<p>优点在于 tractability。 缺点在于并非均值回归。</p>
<h3 id="the-black-derman-toybdt-model">The Black-Derman-Toy(BDT) model</h3>
<p><span class="math display">\[r_{i,j} = a_i e^{b_i j}\]</span></p>
<p><span class="math display">\[\ln{r_{i,j}} = \log{a_i} + b_i j\]</span></p>
<p>连续时间 记 <span class="math inline">\(Y_t := \ln{r_t}\)</span></p>
<p><span class="math display">\[dY_t = \left( a_t + \frac1{\sigma t}\frac{\partial \sigma}{\partial t} Y_t \right)dt + \sigma_t dW_t\]</span></p>
<h3 id="校正期限结构">校正期限结构</h3>
<p>假设市场的利率期限结构 spot rate</p>
<p><span class="math display">\[(s_1, ..., s_n)\]</span></p>
<p><strong>则 <span class="math inline">\(t\)</span> 时刻的 $ $1 $ 按照 <span class="math inline">\(s_t\)</span> 折现，应该等于该时刻的状态价格相加。</strong></p>
<p>为简化，假设 <span class="math inline">\(b\)</span> 取相同值。</p>
<p><span class="math display">\[\begin{aligned}
\frac{1}{(1+s_i)^i} &amp;= \sum_{j=0}^i{P_e(i,j)}\\
&amp;= \frac{P_e(i-1, 0)}{2(1+r_{i-1, 0)}} + \frac{P_e(i-1, i-1)}{2(1 + r_{i-1,i-1})} + \sum_{j=1}^{i-1}{\left(\frac{P_e(i-1, j)}{2(1+r_{i-1, j})} + \frac{P_e(i-1, j-1)}{2(1+r_{i-1, j-1})} \right) } \\
&amp;= \frac{P_e(i-1, 0)}{2(1+a_{i-1})} + \frac{P_e(i-1, i-1)}{2(1+a_{i-1}e^{b(i-1)})} + \sum_{j=1}^{i-1}{\left(\frac{P_e(i-1, j)}{2(1+a_{i-1} e^{b j})} + \frac{P_e(i-1, j-1)}{2(1+a_{i-1} e^{b (j-1)})} \right) } \\
\end{aligned}\]</span></p>
<p>根据已有的利率期限结构，前向更新二叉树，求解 <span class="math inline">\(a_i\)</span>。</p>
<h4 id="例8-使用bdt模型为-payer-swaption-定价">例8 使用BDT模型为 payer swaption 定价。</h4>
<p>题设： 2-8，给出利率期限结构，payer pay fixed and receive floating。 fixed rate = 11.65%。</p>
<p>题解：和前例的 (e) 类似。首先 BDT 校正确定 short rate lattice，然后基于此定价。每一次交换折算到上一个时间点上 (为何折算？因为可以确定地分配到父节点上)；swap的价值向前折算累计；到 t=2 时，注意该 swaption 由于其期权性质，价格非负。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BDT_solver</span>(<span class="params">arr_s: np.array, b: float</span>):</span></span><br><span class="line">    T = len(arr_s)</span><br><span class="line">    Pe = np.ones((T + <span class="number">1</span>, T + <span class="number">1</span>)) * np.nan</span><br><span class="line">    Pe[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    arr_a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, T + <span class="number">1</span>):</span><br><span class="line">        left_side = <span class="number">1</span> / (<span class="number">1</span> + arr_s[i - <span class="number">1</span>])**i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">target</span>(<span class="params">a_im1</span>):</span></span><br><span class="line">            right_side = Pe[i<span class="number">-1</span>, <span class="number">0</span>] / <span class="number">2</span>/(<span class="number">1</span>+a_im1) + \</span><br><span class="line">                    np.sum( [(Pe[i<span class="number">-1</span>, j] /<span class="number">2</span> /(<span class="number">1</span>+a_im1*np.exp(b*j)) + Pe[i<span class="number">-1</span>, j<span class="number">-1</span>] / <span class="number">2</span> / (<span class="number">1</span>+a_im1*np.exp(b*(j<span class="number">-1</span>)))) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i)] ) + \</span><br><span class="line">                    Pe[i<span class="number">-1</span>, i<span class="number">-1</span>] / <span class="number">2</span> / (<span class="number">1</span> + a_im1*np.exp(b*(i<span class="number">-1</span>)))</span><br><span class="line">            <span class="keyword">return</span> (left_side - right_side)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        res = minimize(target, <span class="number">0</span>)</span><br><span class="line">        a_im1 = res.x</span><br><span class="line">        <span class="comment"># print(f&quot;a&#123;i-1&#125;: &#123;a_im1&#125;&quot;)</span></span><br><span class="line">        arr_a.append(a_im1)</span><br><span class="line">        Pe[i, <span class="number">0</span>] = Pe[i - <span class="number">1</span>, <span class="number">0</span>] / <span class="number">2</span> / (<span class="number">1</span> + a_im1)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">            Pe[i, j] = Pe[i - <span class="number">1</span>, j] / <span class="number">2</span> / (<span class="number">1</span> + a_im1 * np.exp(b * j)) + Pe[</span><br><span class="line">                i - <span class="number">1</span>, j - <span class="number">1</span>] / <span class="number">2</span> / (<span class="number">1</span> + a_im1 * np.exp(b * (j - <span class="number">1</span>)))</span><br><span class="line">        Pe[i, i] = Pe[i - <span class="number">1</span>, i - <span class="number">1</span>] / <span class="number">2</span> / (<span class="number">1</span> + a_im1 * np.exp(b * (i - <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">return</span> Pe, np.array(arr_a).flatten()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr_s = np.array([<span class="number">7.3</span>, <span class="number">7.62</span>, <span class="number">8.1</span>, <span class="number">8.45</span>, <span class="number">9.2</span>, <span class="number">9.64</span>, <span class="number">10.12</span>, <span class="number">10.45</span>, <span class="number">10.75</span>, <span class="number">11.22</span>]) / <span class="number">100</span></span><br><span class="line">b = <span class="number">0.005</span></span><br><span class="line"></span><br><span class="line">Pe, a = BDT_solver(arr_s,b)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pe.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[1.   ,   nan,   nan,   nan,   nan,   nan,   nan,   nan,   nan,
          nan,   nan],
       [0.466, 0.466,   nan,   nan,   nan,   nan,   nan,   nan,   nan,
          nan,   nan],
       [0.216, 0.432, 0.216,   nan,   nan,   nan,   nan,   nan,   nan,
          nan,   nan],
       [0.099, 0.297, 0.297, 0.099,   nan,   nan,   nan,   nan,   nan,
          nan,   nan],
       [0.045, 0.181, 0.271, 0.181, 0.045,   nan,   nan,   nan,   nan,
          nan,   nan],
       [0.02 , 0.101, 0.201, 0.201, 0.1  , 0.02 ,   nan,   nan,   nan,
          nan,   nan],
       [0.009, 0.054, 0.135, 0.18 , 0.135, 0.054, 0.009,   nan,   nan,
          nan,   nan],
       [0.004, 0.028, 0.084, 0.139, 0.139, 0.083, 0.028, 0.004,   nan,
          nan,   nan],
       [0.002, 0.014, 0.05 , 0.099, 0.123, 0.099, 0.049, 0.014, 0.002,
          nan,   nan],
       [0.001, 0.007, 0.028, 0.066, 0.098, 0.098, 0.065, 0.028, 0.007,
        0.001,   nan],
       [0.   , 0.003, 0.015, 0.041, 0.071, 0.085, 0.071, 0.04 , 0.015,
        0.003, 0.   ]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.round(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([0.073, 0.079, 0.09 , 0.094, 0.121, 0.117, 0.129, 0.126, 0.129,
       0.152])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use ai &amp; b to derive r_ij</span></span><br><span class="line">short_rate_lattice = np.tril(np.outer(a, np.exp(np.arange(T)*b))).round(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Change 0 to np.nan</span></span><br><span class="line">short_rate_lattice = np.where(short_rate_lattice==<span class="number">0</span>, np.nan, short_rate_lattice)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">short_rate_lattice</span><br></pre></td></tr></table></figure>
<pre><code>array([[0.073 ,    nan,    nan,    nan,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.0792, 0.0796,    nan,    nan,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.0902, 0.0907, 0.0911,    nan,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.0944, 0.0948, 0.0953, 0.0958,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.1213, 0.1219, 0.1225, 0.1231, 0.1238,    nan,    nan,    nan,
           nan,    nan],
       [0.1172, 0.1178, 0.1184, 0.119 , 0.1195, 0.1201,    nan,    nan,
           nan,    nan],
       [0.1285, 0.1292, 0.1298, 0.1305, 0.1311, 0.1318, 0.1324,    nan,
           nan,    nan],
       [0.1257, 0.1263, 0.1269, 0.1276, 0.1282, 0.1288, 0.1295, 0.1301,
           nan,    nan],
       [0.1292, 0.1298, 0.1305, 0.1311, 0.1318, 0.1325, 0.1331, 0.1338,
        0.1345,    nan],
       [0.1519, 0.1527, 0.1535, 0.1542, 0.155 , 0.1558, 0.1566, 0.1573,
        0.1581, 0.1589]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(short_rate_lattice[<span class="number">9</span>] - <span class="number">0.1165</span>) / (<span class="number">1</span>+short_rate_lattice[<span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<pre><code>array([0.03073183, 0.03140453, 0.03207629, 0.03266332, 0.03333333,
       0.03400242, 0.03467059, 0.03525447, 0.0359209 , 0.03658642])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">swaption_lattice = np.ones_like(short_rate_lattice) * np.nan</span><br><span class="line">swaption_lattice[<span class="number">9</span>] = (short_rate_lattice[<span class="number">9</span>] - <span class="number">0.1165</span>) / (<span class="number">1</span>+short_rate_lattice[<span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">8</span>, <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">    swaption_lattice[t, :t+<span class="number">1</span>] = (short_rate_lattice[t, :t+<span class="number">1</span>] - <span class="number">0.1165</span>) / (<span class="number">1</span>+short_rate_lattice[t, :t+<span class="number">1</span>]) + (<span class="number">0.5</span> * swaption_lattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] + <span class="number">0.5</span> * swaption_lattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]  ) / (<span class="number">1</span>+ short_rate_lattice[t, :t+<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swaption_lattice.round(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>array([[    nan,     nan,     nan,     nan,     nan,     nan,     nan,
            nan,     nan,     nan],
       [    nan,     nan,     nan,     nan,     nan,     nan,     nan,
            nan,     nan,     nan],
       [-0.0018,  0.0011,  0.004 ,     nan,     nan,     nan,     nan,
            nan,     nan,     nan],
       [ 0.0231,  0.0257,  0.0284,  0.0311,     nan,     nan,     nan,
            nan,     nan,     nan],
       [ 0.0461,  0.0486,  0.0511,  0.0535,  0.056 ,     nan,     nan,
            nan,     nan,     nan],
       [ 0.0458,  0.048 ,  0.0502,  0.0524,  0.0546,  0.0568,     nan,
            nan,     nan,     nan],
       [ 0.0495,  0.0514,  0.0533,  0.0553,  0.0571,  0.059 ,  0.0609,
            nan,     nan,     nan],
       [ 0.0431,  0.0446,  0.0461,  0.0477,  0.0492,  0.0507,  0.0523,
         0.0538,     nan,     nan],
       [ 0.0388,  0.0399,  0.041 ,  0.0421,  0.0433,  0.0444,  0.0455,
         0.0466,  0.0478,     nan],
       [ 0.0307,  0.0314,  0.0321,  0.0327,  0.0333,  0.034 ,  0.0347,
         0.0353,  0.0359,  0.0366]])</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># the swaption (option) is exercised only if S2&gt;0. </span></span><br><span class="line">swaption_lattice[<span class="number">2</span>] = np.clip(swaption_lattice[<span class="number">2</span>], <span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    swaption_lattice[t, :t+<span class="number">1</span>] =  (<span class="number">0.5</span> * swaption_lattice[t+<span class="number">1</span>, <span class="number">1</span>:t+<span class="number">2</span>] + <span class="number">0.5</span> * swaption_lattice[t+<span class="number">1</span>, :t+<span class="number">1</span>]  ) / (<span class="number">1</span>+ short_rate_lattice[t, :t+<span class="number">1</span>])</span><br><span class="line">swaption_lattice.round(<span class="number">4</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>array([[0.0013,    nan,    nan,    nan,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.0005, 0.0024,    nan,    nan,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.    , 0.0011, 0.004 ,    nan,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.0231, 0.0257, 0.0284, 0.0311,    nan,    nan,    nan,    nan,
           nan,    nan],
       [0.0461, 0.0486, 0.0511, 0.0535, 0.056 ,    nan,    nan,    nan,
           nan,    nan],
       [0.0458, 0.048 , 0.0502, 0.0524, 0.0546, 0.0568,    nan,    nan,
           nan,    nan],
       [0.0495, 0.0514, 0.0533, 0.0553, 0.0571, 0.059 , 0.0609,    nan,
           nan,    nan],
       [0.0431, 0.0446, 0.0461, 0.0477, 0.0492, 0.0507, 0.0523, 0.0538,
           nan,    nan],
       [0.0388, 0.0399, 0.041 , 0.0421, 0.0433, 0.0444, 0.0455, 0.0466,
        0.0478,    nan],
       [0.0307, 0.0314, 0.0321, 0.0327, 0.0333, 0.034 , 0.0347, 0.0353,
        0.0359, 0.0366]])</code></pre>
<h2 id="讲义">讲义</h2>
<div class="pdfobject-container" data-target="./3lattice_models.pdf" data-height="1000px"></div>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Financial-Engineering/" rel="tag"># Financial Engineering</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/15/IEOR-E4706-Martingale-Pricing-Theory-Discrete-Time-Space/" rel="prev" title="IEOR E4706: Martingale Pricing Theory (Discrete Time&Space)">
      <i class="fa fa-chevron-left"></i> IEOR E4706: Martingale Pricing Theory (Discrete Time&Space)
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/27/IEOR-E4706-Mean-Variance-Optimization-and-the-CAPM/" rel="next" title="IEOR E4706: Mean-Variance Optimization and the CAPM">
      IEOR E4706: Mean-Variance Optimization and the CAPM <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">1.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">二叉树模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E6%97%A0%E5%A5%97%E5%88%A9%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.</span> <span class="nav-text">构造一个无套利的二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0%E5%88%A9%E7%8E%87%E6%9C%9F%E9%99%90%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">从二叉树到利率期限结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%8E%87%E8%A1%8D%E7%94%9F%E5%93%81%E5%AE%9A%E4%BB%B7"><span class="nav-number">2.3.</span> <span class="nav-text">利率衍生品定价</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BA%E5%88%B8%E7%9A%84%E6%9C%9F%E6%9D%83"><span class="nav-number">2.3.1.</span> <span class="nav-text">债券的期权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BA%E5%88%B8%E7%9A%84%E6%9C%9F%E8%B4%A7"><span class="nav-number">2.3.2.</span> <span class="nav-text">债券的期货</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BA%E5%88%B8%E7%9A%84%E8%BF%9C%E6%9C%9F"><span class="nav-number">2.3.3.</span> <span class="nav-text">债券的远期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%9F%E8%B4%A7%E5%92%8C%E8%BF%9C%E6%9C%9F%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">2.3.4.</span> <span class="nav-text">期货和远期的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%8E%87%E4%B8%8A%E9%99%90-caplet-%E7%9A%84%E5%AE%9A%E4%BB%B7"><span class="nav-number">2.3.5.</span> <span class="nav-text">利率上限 Caplet 的定价</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-forward-equations"><span class="nav-number">3.</span> <span class="nav-text">The Forward Equations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%AF%B9%E5%86%B2%E4%BE%8B7"><span class="nav-number">3.1.</span> <span class="nav-text">二叉树中的对冲，例7</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#some-specific-models"><span class="nav-number">4.</span> <span class="nav-text">Some specific models</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#the-ho-lee-model"><span class="nav-number">4.1.</span> <span class="nav-text">The Ho-Lee Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-black-derman-toybdt-model"><span class="nav-number">4.2.</span> <span class="nav-text">The Black-Derman-Toy(BDT) model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%A1%E6%AD%A3%E6%9C%9F%E9%99%90%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">校正期限结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B8-%E4%BD%BF%E7%94%A8bdt%E6%A8%A1%E5%9E%8B%E4%B8%BA-payer-swaption-%E5%AE%9A%E4%BB%B7"><span class="nav-number">4.3.1.</span> <span class="nav-text">例8 使用BDT模型为 payer swaption 定价。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B9%89"><span class="nav-number">5.</span> <span class="nav-text">讲义</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="姚华(Hua Yao)"
      src="https://avatars2.githubusercontent.com/u/54726816?s=460&u=39a4b895b570f1c0a114d932d9eff85d49cbe399&v=4">
  <p class="site-author-name" itemprop="name">姚华(Hua Yao)</p>
  <div class="site-description" itemprop="description">hy2632@columbia.edu</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hy2632" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hy2632" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hy2632@columbia.edu" title="E-Mail → mailto:hy2632@columbia.edu" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.instagram.com/nocturnima1/" title="Instagram → https:&#x2F;&#x2F;www.instagram.com&#x2F;nocturnima1&#x2F;" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">姚华(Hua Yao)</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://huo-meng-lou.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://hy2632.github.io/2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/";
    this.page.identifier = "2021/02/27/IEOR-E4706-Term-Structure-Lattice-Models/";
    this.page.title = "IEOR E4706: Term Structure Lattice Models";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://huo-meng-lou.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
