<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CS224NA5</title>
    <url>/2020/08/20/CS224NA5/</url>
    <content><![CDATA[<h1 id="cs224n-assignment-5">CS224N Assignment #5</h1>
<p>(7.20)增加 Pylance 插件作为语言服务器. 打开 type checking mode(basic).</p>
<h2 id="文字题">文字题</h2>
<ul>
<li><ol type="a">
<li>We learned in class that recurrent neural architectures can operate over variable length input (i.e., the shape of the model parameters is independent of the length of the input sentence). Is the same true of convolutional architectures? Write one sentence to explain why or why not.</li>
</ol>
<p>window t ∈ {1, . . . , mword − k + 1}， mword 即最长单词的长度可变， xconv ∈ R^(eword×(mword−k+1))</p></li>
<li><p>(b)...if we use the kernel size k = 5, what will be the size of the padding (i.e. the additional number of zeros on each side) we need for the 1-dimensional convolution, such that there exists at least one window for all possible values of mword in our dataset?</p>
<p>极端情况 mword=1， 前后各 1 个 token，还需 padding=1.</p></li>
<li><ol start="3" type="a">
<li>In step 4, we introduce a Highway Network with <code>xhighway = xgate xproj + (1 − xgate) xconv out</code>. Since xgate is the result of the sigmoid function, it has the range (0, 1).Consider the two extreme cases. If xgate → 0, then xhighway → xconv out. When xgate → 1, then xhighway → xproj. This means the Highway layer is smoothly varying its behavior between that of normal linear layer (xproj) and that of a layer which simply passes its inputs (xconv out) through. Use one or two sentences to explain why this behavior is useful in character embeddings. Based on the definition of <code>xgate = σ(Wgatexconv out + bgate)</code>, do you think it is better to initialize bgate to be negative or positive? Explain your reason briefly. 原因： 所谓的 highway， x_gate=0 可以直接用 x_convout 的值。</li>
</ol>
<p>希望默认 x_gate 较小方便 highway，所以 b 取负。</p></li>
<li><ol start="4" type="a">
<li>In Lecture 10, we briefly introduced Transformers, a non-recurrent sequence (or sequence-to-sequence) model with a sequence of attention-based transformer blocks. Describe 2 advantages of a Transformer encoder over the LSTM-with-attention encoder in our NMT model</li>
</ol>
<p>可以看一下 &lt;<Attention is all you need>&gt;： "Self-attention, sometimes called intra-attention is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence." 每一步都是句子里的所有单词之间建立联系。 主要用到三个矩阵 Key, Query, value, <code>Attention(Q,K,V) = softmax(QK.T/\sqrt(d_k))V</code> (包学包会，这些动图和代码让你一次读懂「自注意力」 - 机器之心的文章 - 知乎 https://zhuanlan.zhihu.com/p/96492170)</p>
<p>attention-based transformers的好处（P6 的 Part 4， Why self-attention）：</p>
<p>未采用RNN就可以避免梯度消失和梯度爆炸等问题, 从sequential computation 到实现parallelized computation, 更易学习到"long-range dependencies in the network", 更加interpretable.</p></li>
</ul>
<h1 id="character-based-convolutional-encoder-for-nmt-36-points">1. Character-based convolutional encoder for NMT (36 points)</h1>
<h2 id="vocab.py">Vocab.py</h2>
<ol type="1">
<li>这种写法很巧妙·</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(self.char_list):</span><br><span class="line">    self.char2id[c] = len(self.char2id)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>组合用法，类似 zip+enumerate <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">word_freq = Counter(chain(\*corpus))</span><br></pre></td></tr></table></figure></p></li>
<li><p>用字典辅助排序 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">valid_words = [w <span class="keyword">for</span> w, v <span class="keyword">in</span> word_freq.items() <span class="keyword">if</span> v &gt;= freq_cutoff]</span><br><span class="line">top_k_words = sorted(valid_words, key=<span class="keyword">lambda</span> w: word_freq[w], reverse=<span class="literal">True</span>[:size]</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>用到了<code>json.dump</code>，Vocab 也用此形式存储。</p>
<h2 id="e-implement-to_input_tensor_char-in-vocab.py">(e) Implement <code>to_input_tensor_char()</code> in <code>vocab.py</code></h2>
<p>字母 ∏ Û python 执行有问题，改成<code>&lt;pad&gt;</code>, <code>&lt;unk&gt;</code>。</p>
<h2 id="f-highway">(f) highway</h2>
<p>要求写一个 sanity_check, (f)本身实现很简单，只是一步处理，所以检查一下前后维度就可以。</p>
<h2 id="g-cnn.py-cnn">(g) cnn.py, CNN</h2>
<p>输入(sentence_length, batch_size, e_char, m_word)，前两维不动，对每个词 conv 完，后两维应该是 f 和窗口数，再经过 maxpool 所有窗口， 输出是(sentence_length, batch_size, f) torch 需要使用.contiguous().view(),因为 view 只能作用在 contiguous 的变量上 比较关键的一步。 <strong>07/25 更新</strong>： 果然后面还是出问题了。m_word 是 forward 函数中参数 x_reshaped 的维度属性，如果使用 max_pool layer，一开始并不知道输入的参数 m_word 是多少。所以不应该用 maxpool 层（因为不能对一个多维 tensor 的某一维更新）， 而应该在 forward 函数里直接调用 torch.max(dim=2)</p>
<h2 id="h-model_embeddings.">(h) Model_Embeddings.</h2>
<p>一个问题是 f=e_word, e_word 和 e_char 的关系到底如何？？ 题目假设 e_char=50, e_word 是初始化 model_embeddings 的参数 word_embedding_size, 默认值 21。</p>
<h2 id="j">(j)</h2>
<p>wdnmd， vocab.py 里的 sents_var 总是空的，查了半天发现 utils.pad_sents 忘了粘贴。 nmt_model.py 中 step()函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> enc*masks <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    e_t.data.masked_fill*(enc_masks.bool(), -float(<span class="string">&#x27;inf&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>显示'Tensor' object has no attribute 'bool' 原因应该是 torch 版本较低 事实也确实如此，local*env.yml 显示 pytorch=1.0.0，a4 作业就没有限定版本，估计是助教忘了更新。 解决方案：改成 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e_t.data.masked_fill*(enc_masks==<span class="number">1</span>, -float(<span class="string">&#x27;inf&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">epoch 100, iter 500, cum. loss 0.30, cum. ppl 1.01 cum. examples 200</span><br><span class="line">validation: iter 500, dev. ppl 1.001988</span><br><span class="line">Corpus BLEU: 99.66941696422141</span><br></pre></td></tr></table></figure>
<p>达到题设要求。</p>
<h1 id="character-based-lstm-decoder-for-nmt-26-points">2. Character-based LSTM decoder for NMT (26 points)</h1>
<h2 id="b">(b)</h2>
<p>奇怪的点在于, char_decoder.py 中 train_forward 的 loss 计算，不 softmaxloss 才收敛。 题目要求仔细阅读 nn.CrossEntropyLoss，实际上 Pytorch 中 CrossEntropyLoss()函数将 softmax-log-NLLLoss 合并到一块。</p>
<p><code>This criterion combines nn.LogSoftmax() and nn.NLLLoss() in one single class.</code> loss 0.38, Corpus BLEU: 99.66941696422141</p>
<h2 id="c">(c)</h2>
<p>这部分思路很清晰，用到了一些技巧，比如(tensor,tensor)的 elementwise 的提取，char 拼接成 word 等，详见代码</p>
<h2 id="e">(e)</h2>
<p>在 VM 上训练。 注意 run.sh 可以进行修改，使得 train_local 也可使用 cuda，提高效率。 仍然遇到了环境问题。 “RuntimeError: Given input size: (256x1x12). Calculated output size: (256x1x0). Output size is too small” 于是只能在 VM 上配一个和本地相同的（过时的）环境。问题解决。 <strong>CNN.py 中存在问题，很久之前埋下的坑！！！</strong>：初始化时如果建立 maxpool 就需要提前知道 m_word 以确定 kernel_size。这个问题可以这样解决：避免 maxpool 层，在 forward 中使用 torch.max 函数，对某个维度进行 max。 对 cnn 和 sanity_check 都进行修改。由于默认使用了 sanitycheck 的值 m_word=21,实际上在写其他函数调用 CNN 类的时候没有定义 m_word 值，所以正好不需要改。 参考：Tessa Scott<a href="https://github.com/tessascott039/a5/blob/master/cnn.py" class="uri">https://github.com/tessascott039/a5/blob/master/cnn.py</a></p>
<p><a href="https://github.com/pytorch/pytorch/issues/4166" class="uri">https://github.com/pytorch/pytorch/issues/4166</a> <a href="https://stackoverflow.com/questions/56137869/is-it-possible-to-make-a-max-pooling-on-dynamic-length-sentences-without-padding" class="uri">https://stackoverflow.com/questions/56137869/is-it-possible-to-make-a-max-pooling-on-dynamic-length-sentences-without-padding</a> 探讨了 nn.MaxPool1d 能不能有一个动态的 kernel_size。</p>
<p>train 的结果： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">epoch 29, iter 196300, avg. loss 81.60, avg. ppl 59.75 cum. examples 9600, speed 6086.86 words&#x2F;sec, time elapsed 20580.30 sec</span><br><span class="line">epoch 29, iter 196310, avg. loss 81.10, avg. ppl 50.14 cum. examples 9920, speed 6458.96 words&#x2F;sec, time elapsed 20581.33 sec</span><br><span class="line">epoch 29, iter 196320, avg. loss 78.58, avg. ppl 48.75 cum. examples 10240, speed 6548.57 words&#x2F;sec, time elapsed 20582.32 sec</span><br><span class="line">epoch 29, iter 196330, avg. loss 86.52, avg. ppl 61.24 cum. examples 10537, speed 6019.06 words&#x2F;sec, time elapsed 20583.36 sec</span><br><span class="line">test：Corpus BLEU: 36.395796664198</span><br></pre></td></tr></table></figure></p>
<h1 id="analyzing-nmt-systems-8-points">3. Analyzing NMT Systems (8 points)</h1>
<h2 id="a">(a)</h2>
<p>用 linux 的 grep 命令查找字符串 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(base) hy2632_ubuntu20@DESKTOP-8LEIHPS:~&#x2F;cs224n&#x2F;a5_public\$ grep tradu vocab.json</span><br><span class="line">&quot;traduciendo&quot;: 17349,</span><br><span class="line">&quot;tradujera&quot;: 32719,</span><br><span class="line">&quot;traduccin&quot;: 4562,</span><br><span class="line">&quot;traduzco&quot;: 40154,</span><br><span class="line">&quot;traduzcan&quot;: 23440,</span><br><span class="line">&quot;traductores&quot;: 19447,</span><br><span class="line">&quot;traducir&quot;: 4565,</span><br><span class="line">&quot;traducciones&quot;: 12054,</span><br><span class="line">&quot;traductor&quot;: 11809,</span><br><span class="line">&quot;traducirse&quot;: 36917,</span><br><span class="line">&quot;traducen&quot;: 19640,</span><br><span class="line">&quot;tradujo&quot;: 25176,</span><br><span class="line">&quot;traducido&quot;: 8515,</span><br><span class="line">&quot;traducimos&quot;: 18251,</span><br><span class="line">&quot;traduce&quot;: 7821,</span><br><span class="line">&quot;traducidas&quot;: 20336,</span><br><span class="line">&quot;traduzca&quot;: 44710,</span><br><span class="line">&quot;traducirlo&quot;: 19205,</span><br><span class="line">&quot;traductora&quot;: 13071,</span><br><span class="line">&quot;traduje&quot;: 23103,</span><br><span class="line">&quot;traducirlas&quot;: 35543,</span><br><span class="line">&quot;traducida&quot;: 19350,</span><br></pre></td></tr></table></figure></p>
<p>traduces, traduzcas not in. 如果是 word-based NMT，将 spanish 翻译为 english， 如果句子中出现 traduces 就会判断为<code>&lt;unk&gt;</code>， 无法翻译；但如果是 character-aware NMT，别的类似 traducir(to translate)的动词可能有类似的性质(加 s，从 I 变成 you)，同时又恰好出现在训练集中，那么模型在遇到 traduces 的 s 时就能翻译出 you translate。</p>
<h2 id="b-1">(b)</h2>
<ol type="1">
<li><p>回顾 Word2Vec。<a href="https://projector.tensorflow.org/" class="uri">https://projector.tensorflow.org/</a> 可以查询 k-nearest words。</p>
<p>Markdown 表格生成<a href="https://www.tablesgenerator.com/markdown_tables" class="uri">https://www.tablesgenerator.com/markdown_tables</a></p></li>
</ol>
<table>
<thead>
<tr class="header">
<th>word</th>
<th>closest word</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>financial</td>
<td>economics</td>
</tr>
<tr class="even">
<td>neuron</td>
<td>nerve</td>
</tr>
<tr class="odd">
<td>Francisco</td>
<td>san</td>
</tr>
<tr class="even">
<td>naturally</td>
<td>occurring</td>
</tr>
<tr class="odd">
<td>expectation</td>
<td>norms</td>
</tr>
</tbody>
</table>
<ol start="2" type="1">
<li>也可以上传自己的 character-aware NMT model 的 embeddings 查找 nearest neighbors.</li>
</ol>
<figure>
<img src="https://raw.githubusercontent.com/hy2632/cs224n/master/a5_public/CS224n-A5-emb2-files/embedding_proj.jpg" alt="" /><figcaption>Image</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>word</th>
<th>closest word</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>financial</td>
<td>vertical</td>
</tr>
<tr class="even">
<td>neuron</td>
<td>Newton</td>
</tr>
<tr class="odd">
<td>Francisco</td>
<td>France</td>
</tr>
<tr class="even">
<td>naturally</td>
<td>practically</td>
</tr>
<tr class="odd">
<td>expectation</td>
<td>exception</td>
</tr>
</tbody>
</table>
<ol start="3" type="1">
<li>分析 Word2Vec 和 CharCNN 的区别并解释。</li>
</ol>
<p>除了 naturally/practically 意思相近，CharCNN 的 embeddings 更多的还是按照字母组成（同时也包含一些 pos 和 ner）。Word2Vec 则更多地把握了词义的相似和关联性。原因就是模型本身。</p>
<p>word2vec: skip-grams &amp; CBOW(contiguous bag of words)，给定上下文此预测缺失的中心词 c，概率分布 P(C|W)。因而相近的词都是有较大概率作为中心词被代替。</p>
<p>CharCNN: 对某个单词的各个字母进行 charembedding，然后经过 CNN/Highway 等操作最后生成 wordembedding，较大程度上依赖于 charembedding，如果两个词有相同字母的 subset 则 wordembedding 可能相近。</p>
<h2 id="c-1">(c)</h2>
<p>(45)正确的例子： | Category | | | -------------- | -------------------------------------------------------------------------- | | ES | A medida que se derrite un tmpano, estoy respirando su atmsfera ancestral. | | Ref | As an eardrum melts, I am breathing in its ancient atmosphere. | | A4 translation | As a <code>&lt;unk&gt;</code> <code>&lt;unk&gt;</code> I'm breathing its atmosphere <code>&lt;unk&gt;</code> | | A5 translation | As it melts a iceberg, I'm breathing its ancestral atmosphere. |</p>
<p>tímpano，témpano 是同义词，但一个翻译为耳膜一个翻译为冰山。这里冰山显然更为合适。</p>
<p>(85)错误的例子： | Category | | | -------------- | ------------------------------------------------- | | ES | Es el sndrome de insensibilidad a los andrgenos. | | Ref | It is the syndrome of insensitivity to androgens. | | A4 translation | It's called <code>&lt;unk&gt;</code> <code>&lt;unk&gt;</code> | | A5 translation | It's the syndrome of insulin insulin. |</p>
<p>对于连续的<code>&lt;unk&gt;</code>，CharCNN 的表现并没有很好改善（重复出现的 insulin）。</p>
]]></content>
      <categories>
        <category>CS224N作业笔记</category>
      </categories>
      <tags>
        <tag>CS224N</tag>
      </tags>
  </entry>
  <entry>
    <title>8/27OW分享会记录</title>
    <url>/2020/08/29/0827OW/</url>
    <content><![CDATA[<h2 id="basic-info">Basic Info</h2>
<p>Offices: BJ, SH, HK.</p>
<p>技能点：</p>
<ul>
<li>Big data</li>
<li>data mining</li>
<li>machine learning</li>
<li>analytical problem solving</li>
<li>co-creation</li>
<li>design thinking</li>
<li>change enablement</li>
<li>people effectiveness</li>
</ul>
<p>发展路径: 前三年跨行业</p>
<h2 id="project-span-industries-and-capabilities">Project span industries and capabilities</h2>
<p>行业：健康， 消费者工业和服务（教育 房地产）， 金融服务 <img src="https://raw.githubusercontent.com/hy2632/hy2632.github.io/master/2020/08/29/0827OW/span.jpg" alt="Image" /> 横向：不同division和三大类 纵向：不同行业</p>
<h2 id="recruiting">Recruiting</h2>
<p>digital interview: Oct 14, first round interview Oct 25, final round Oct 30. <img src="https://raw.githubusercontent.com/hy2632/hy2632.github.io/master/2020/08/29/0827OW/recruitinginfo.jpg" alt="Image" /></p>
<h2 id="breakout-room-life-as-a-new-consultant-digital-qa">Breakout room (Life as a new consultant + Digital), Q&amp;A</h2>
<figure>
<img src="https://raw.githubusercontent.com/hy2632/hy2632.github.io/master/2020/08/29/0827OW/breakoutrooms.jpg" alt="" /><figcaption>Image</figcaption>
</figure>
<h3 id="相对甲方战略咨询部的特点">相对甲方战略咨询部的特点</h3>
<ol type="1">
<li><p>行业选择</p></li>
<li><p>紧迫感，下一个30天、100天做什么</p></li>
<li><p>好的甲方的核心业务可能比咨询更优，因为有经验积淀</p></li>
<li><p>大厂有丰富的大数据</p></li>
<li><p>乙方咨询还有换赛道的机会，甲方从零开始</p></li>
<li><p>OW的Know:知识库 即插即用</p></li>
<li><p>甲方：战略部 -&gt; 策略部(市场策略)</p></li>
<li><p>咨询的生命周期可能是长期的，专注于商业本质，“无限游戏”</p></li>
<li><p>consultant和engineer合作更加紧密，有multinational的know平台，以及和客户ceo之类有很好的关系和实施的渠道</p></li>
</ol>
<h3 id="简要介绍不同的digital-transformation">简要介绍不同的digital transformation</h3>
<ol type="1">
<li>分行业分业务</li>
<li>例如保险 搬到线上 高净值人群需要线下服务，其实不是对象，应当优化大部分普通客户的流程。</li>
<li>digital products: 把社交媒体如微博的data变为insights，和客户一起探讨，确定客户在意的数据：例如被提到次数、提到内容、注意点。帮助识别emerging brand小众品牌，发现潜在competitors。</li>
<li>data product(server)/data government，组织形式，和各个公司有关</li>
<li>big data可以帮助做datadriven decision， 如促销机制，之前没有理论指导人为因素较大，利用大数据给出的解决方案包含数据分析和专家访谈，确定更换促销机制的周期以及更细致的客户targeting</li>
<li>总而言之可以高层次爷可接地气</li>
</ol>
<h3 id="需要编程技能">需要编程技能</h3>
<ol type="1">
<li>DE/DS/DC，DC除了技能还需要理解<strong>Business Implementation</strong></li>
<li>python必需，还要高效使用package；SQL可以现学</li>
<li>需要学过BA课程， 熟悉pandas/matplotlib等，可以看一些互联网PM的书籍，了解如何分析客户和产品，获得Business Insights</li>
<li><strong>Business implementation 不只是向客户摆事实，而应该告诉客户做什么，例如上新品类，好处的量化</strong></li>
</ol>
<h3 id="digital的发展路径">Digital的发展路径</h3>
<p>不是纵向而是横向，不局限于某个行业，和Operations/Strategy平行</p>
<h3 id="如果business-implementation的阶段性成果未达到预期ow的数字化转型团队有没有调整的机制和经验">如果Business Implementation的阶段性成果未达到预期，OW的数字化转型团队有没有调整的机制和经验</h3>
<ol type="1">
<li>举例: dashboard 的设计调整到更加 user-friendly</li>
<li>说明: 并非一个数字化团队，而是负责数字化的人员一起加入某项目。并非强调准确率，而是“赋能”，有很多qualitative的分析。有时引入新的方法或者数据量不够quant</li>
<li>不是做数据竞赛或做数据框架，而是服务于ceo的模糊想法，是一个工作方向而不是具体地帮助提高销量到某一个值</li>
<li>比如零售商想了解品牌商的想法，而咨询和品牌商有一定合作，可以提供信息</li>
</ol>
<h3 id="new-consultant的经验">new consultant的经验</h3>
<ol type="1">
<li>首先理解任务和clarify</li>
<li>时间紧</li>
<li>汇报要抓重点，不要interesting facts，而是business insights</li>
</ol>
<h3 id="如何知识点成系统">如何知识点成系统</h3>
<ol type="1">
<li>例如研究券商的core trade system</li>
<li>expert call,... 有自己的view，并逐渐完善， 除非manager带过类似项目</li>
<li>manager可以quick learning，需要学习这样的能力</li>
<li>项目完成后需要复盘</li>
</ol>
<h3 id="面试经历">面试经历</h3>
<ol type="1">
<li>第一轮笔试，数学题之类</li>
<li>读casebook， 做presentation</li>
<li>manager面 + 面， 两个digital问题</li>
<li><strong>怎么用ml帮netflix提升revenue？？</strong> 应用哪些方面？为什么？多久能达成结果？</li>
</ol>
<h3 id="fast-promotion">fast-promotion</h3>
<ol type="1">
<li>critical thinking, ownership</li>
<li>communication!!! upward and downward对上和对下</li>
<li>接受变化，疫情后医疗更多，很多公司询问疫情影响</li>
<li>学research，学写邮件，善于观察: 别的人怎么做？
<ul>
<li>写title方便locate subproject title</li>
<li>keyfinding 1 2 3, 然后细节定位</li>
<li>最后提需要review回复的时间，方便对方暂时搁置</li>
</ul></li>
<li>为上级考虑，节省上级时间</li>
<li>例如至少code不能有bug</li>
<li>组织events，增加曝光度 (120个同事)，建立工作之外关系</li>
</ol>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Oliver Wyman</tag>
      </tags>
  </entry>
  <entry>
    <title>CS224NA4</title>
    <url>/2020/08/20/CS224NA4/</url>
    <content><![CDATA[<h1 id="cs224n-a4-nmt-assignment">CS224N A4: NMT Assignment</h1>
<p>Note: Heavily inspired by the https://github.com/pcyin/pytorch_nmt repository</p>
<p>作业分为两部分， 第一部分代码实现 NMT with RNN， 第二部分文字题分析 NMT</p>
<h2 id="nmt-with-rnn">1. NMT with RNN</h2>
<ul>
<li>Bidirectional LSTM Encoder &amp; Unidirectional LSTM Decoder</li>
<li>勘误：
<ul>
<li>h 为(embedding size)</li>
<li><strong>(3), (4) 式中的下标 1 应改为 m</strong></li>
</ul></li>
<li><ol type="a">
<li>utils.py</li>
</ol>
<ul>
<li>要求每个 batch 里的句子有相同 length。utils.py 中实现 pad_sents(padding)</li>
</ul></li>
<li><ol start="2" type="a">
<li>model_embeddings.py</li>
</ol>
<ul>
<li>先去 vocab.py 里了解类的定义。</li>
<li>VocabEntry 类初始化参数 word2id(dict: words -&gt; indices), id2word 返回 idx 对应的 word 值，from_corpus 从 corpus 生成一个 VocabEntry 实例，from <strong>collections</strong> import <strong>Counter</strong>，Counter 可以直接查找出字符串中字母出现次数</li>
<li>Vocab 类包含 src 和 tgt 语言，初始化参数式两种语言的 VocabEntry， <span class="citation" data-cites="staticmethod">@staticmethod</span> 静态方法</li>
<li>VocabEntry.from_corpus 创建一个 vocab_entry 对象。Vocab.build 分别用 src_sents, tgt_sents 创建 src, tgt 两个 vocab_entry 并返回包含两者的 Vocab(src, tgt)</li>
<li>运用 nn.Embedding 初始化词嵌。</li>
</ul></li>
<li><ol start="3" type="a">
<li>nmt_model.py</li>
</ol>
<ul>
<li>按照 pdf 中的维度对各层初始化</li>
</ul></li>
<li><ol start="4" type="a">
<li>nmt_model.py 中 encode 方法实现</li>
</ol>
<ul>
<li><code>self.encoder</code> 是一个双向 lstm</li>
<li><code>encode</code> 方法传入两个参数：<code>source_padded, source_lengths</code>。前者是已经 pad 后(src_len, b)的 tensor，每一列是一个句子。后者是一个整数列表，表示每个句子实际多少词。</li>
<li>需要返回两个值：enc_hiddens = hencs(所有 1&lt;=i&lt;=m(句长),每一句中所有词，同时对于整个 batch 所有句子), dec_init_state = (hdec0, cdec0)</li>
<li>lstm 要求输入满足规范形状，所以需要<code>pad_packed_sequence</code> 和<code>packed_pad_sequence</code>进行变形</li>
<li>第一步用<code>self.model_embeddings</code>把 source_padded 转换为词嵌入</li>
</ul></li>
<li><ol start="5" type="a">
<li><code>decode</code>方法</li>
</ol>
<ul>
<li><code>self.decode</code>r 是<code>nn.LSTMCell</code>，返回值 h、c，但这部分包装在 step 里面，本 decode 方法里从<code>self.step</code>取得返回值<code>dec_state, combined_output, e_t</code></li>
<li>还是先用<code>model_embeddings</code>将 target_padded 转换为 Y，一个目标词嵌入，(tgt_len, b, e)</li>
<li>用<code>torch.split</code>方法， 将 Y 按第 0 维分成步长为 1 的步数，相当于逐词(t)操作。</li>
<li>(5)式表明了一个迭代过程，最后关心的<code>combined_outputs</code>是 o_t 集合</li>
<li><strong>07/23 勘误</strong> 做a5时发现dedcode忘记更新o_prev</li>
</ul></li>
<li><ol start="6" type="a">
<li><code>step</code>方法</li>
</ol>
<ul>
<li>step 方法具体处理(5)到(12)式。</li>
<li>第一部分，(5)-(7)，运用 bmm、(un)squeeze。bmm 需要注意第 0 维度是留给 batch_size 的，两个三维 tensor 的第一二维相乘，满足维度要求。常见的是在 dim=1/2 做 unsqueeze，乘完再 squeeze</li>
<li>注意到调换乘法次序+不同的变换维度方式会造成最终结果的精度损失。</li>
</ul></li>
<li><ol start="7" type="a">
<li>文字题：<code>generate_sent_masks()</code> 生成 <code>enc_masks(b, src_len)</code>标识 batch 中每个 sentence 每个词是否是 pad，这样做对 attention 计算的影响以及其必要性。</li>
</ol>
<ul>
<li><code>step</code>中，(8)式 α_t 进行了 softmax，后续 a_t 计算为确保 attention 不受 padding 影响要求 padding 处 α_t=0，即 e_t 设置为-∞。</li>
</ul></li>
<li><ol type="i">
<li></li>
</ol>
<ul>
<li><p>git 配置：git remote add origin https://github.com/hy2632/cs224n.git</p></li>
<li><p>git push origin master</p></li>
<li><p>..</p></li>
<li><p>Corpus BLEU: 31.892219171042335</p></li>
</ul></li>
<li><ol start="10" type="a">
<li><table>
<thead>
<tr class="header">
<th>Attention Type</th>
<th>Advantage</th>
<th>Disadvantage</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dot Product</td>
<td>不需要<code>self.att_projection</code>层</td>
<td>需要满足维度一致</td>
</tr>
<tr class="even">
<td>Multiplicative</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td>Additive</td>
<td>tanh 操作 normalize 了数值</td>
<td>两个参数矩阵，参数更多，空间复杂度大</td>
</tr>
</tbody>
</table></li>
</ol></li>
</ul>
<h2 id="analyzing-nmt-systems-30-points">2. Analyzing NMT Systems (30 points)</h2>
<ul>
<li><p>参考 lec8 slides P50-</p></li>
<li><p>https://www.skynettoday.com/editorials/state_of_nmt</p></li>
<li><p>Out-of-vocabulary words, Domain mismatch between src&amp;tgt, maintaining context over longer text, Low-resource language pairs.</p></li>
<li><ol type="a">
<li></li>
</ol>
<ul>
<li><ol type="i">
<li></li>
</ol>
<ul>
<li><ol type="1">
<li>error: favorite of my favorites,</li>
</ol></li>
<li><ol start="2" type="1">
<li>reason: tgt 库中缺乏 one of my favorites 这样的表达, "Low-resource language pairs"</li>
</ol></li>
<li><ol start="3" type="1">
<li>to fix: 添加训练数据</li>
</ol></li>
</ul></li>
<li><ol start="2" type="i">
<li></li>
</ol>
<ul>
<li><ol type="1">
<li>error: most read 译为了 more reading。</li>
</ol></li>
<li><ol start="2" type="1">
<li>reason: 使用 google translator 发现 ms ledo 被译为 read more， 而 ms ledo en los EEUU 被译为 most read in the US。西班牙语的特点？特定的语言构造。</li>
</ol></li>
<li><ol start="3" type="1">
<li>to fix: 需要让 ms ledo 和后面的定语建立更强的联系，从而把握语义理解。增大 hidden_size</li>
</ol></li>
</ul></li>
<li><ol start="3" type="i">
<li></li>
</ol>
<ul>
<li><ol type="1">
<li>error: "<unk>"</li>
</ol></li>
<li><ol start="2" type="1">
<li>reason: Out-of-vocabulary</li>
</ol></li>
<li><ol start="3" type="1">
<li>to fix: 添加到词表</li>
</ol></li>
</ul></li>
<li><ol start="4" type="i">
<li></li>
</ol>
<ul>
<li><ol type="1">
<li>error: block -&gt; apple</li>
</ol></li>
<li><ol start="2" type="1">
<li>reason: "manzana" 多义性</li>
</ol></li>
<li><ol start="3" type="1">
<li>to fix: 训练集添加 manzana 作为 block 含义的 phrase 数据，且大于“vuelta a la manzana”因为 google translator 仍将该句错译。</li>
</ol></li>
</ul></li>
<li><ol start="22" type="a">
<li></li>
</ol>
<ul>
<li><ol type="1">
<li>error: "la sala de profesores": "teacher's lounge" -&gt; "women's room",</li>
</ol></li>
<li><ol start="2" type="1">
<li>reason: "profesores"应该是复数，不包含性别，该句既错译又包含性别 bias。</li>
</ol></li>
<li><ol start="3" type="1">
<li>to fix: 增加“profesores”/profesor/profesora 的训练数据，平衡性别 bias 的同时也要将 teacher 翻译出来。</li>
</ol></li>
</ul></li>
<li><ol start="6" type="i">
<li></li>
</ol>
<ul>
<li><ol type="1">
<li>error: hectare -&gt; acre</li>
</ol></li>
<li><ol start="2" type="1">
<li>reason: 常识错误，涉及到单位转换</li>
</ol></li>
<li><ol start="3" type="1">
<li>to fix: 没想到好的方法。文章中写：General knowledge about the world is necessary for NMT systems to translate effectively. <strong>However, this knowledge is difficult to encode in its entirety and is not easily extractable from volumes of data. We need mechanisms to incorporate common sense and world knowledge into our neural networks.</strong></li>
</ol></li>
</ul></li>
</ul></li>
<li><ol start="2" type="a">
<li></li>
</ol>
<ul>
<li><p>88:</p>
<ul>
<li>When he 's born , the baby looks a little bit .</li>
<li>When the child is born, she looks like a girl.</li>
<li>Cuando nace, el beb tiene aspecto de nia.(Cuando nace, el bebé tiene aspecto de niña.)</li>
<li>错误：语意，原因：src 本身存在错误无法显示符号，解决方案：样本数据和测试数据的编码格式改一哈</li>
</ul></li>
<li><p>109：</p>
<ul>
<li>So , there are many of a lot of sex .</li>
<li>So sex can come in lots of different varieties.</li>
<li>Entonces, hay muchas variedades de sexo.</li>
<li>错误：语法（many a lot of)，variedades 没有翻译出 variety 的意思。解决方案：增加 muchas variedades 的数据</li>
</ul></li>
</ul></li>
<li><ol start="3" type="a">
<li>BLEU 的定义见 &lt;BLEU: a Method for Automatic Evaluation of Machine Translation&gt; Candidate c, Reference r, BLEU 包含两部分：reference 中出现 candidate 中 ngram phrase 的概率（注意有个 ceiling）和 candidate 太长导致的 brevity penalty。</li>
</ol></li>
<li><ol type="i">
<li></li>
</ol>
<ul>
<li>for c1,
<ul>
<li>p1 = (0 + 1 + 1 + 1 + 0)/5 = 3/5</li>
<li>p2 = (0 + 1 + 1 + 0) /4 = 1/2</li>
<li>len(c) = 5</li>
<li>len(r) = 6</li>
<li>BP = exp(1-6/5) = 0.819</li>
<li><code>BLEU = 0.819 * exp(0.5*log(3/5) + 0.5*log(1/2)) = 0.449</code></li>
</ul></li>
<li>for c2,
<ul>
<li>p1 = (1 + 1 + 0 + 1 + 1)/5 = 4/5</li>
<li>p2 = (1 + 0 + 0 + 1) /4 = 1/2</li>
<li>len(c) = 5</li>
<li>len(r) = 4</li>
<li>BP = 1</li>
<li><code>BLEU = 1 * exp(0.5*log(4/5) + 0.5*log(1/2)) = 0.632</code></li>
</ul></li>
<li>c2 更好。</li>
</ul></li>
<li><ol start="2" type="i">
<li></li>
</ol>
<ul>
<li>c1: p1 = 3/5, p2 = 1/2, BLEU 不变 0.449</li>
<li>c2: p1 = 2/5, p2 = 1/4, len(c) = 5, len(r) = 6, <code>BLEU = 0.819 * exp(0.5*log(2/5) + 0.5*log(1/4)) = 0.259</code></li>
<li>当前 c1 更好。</li>
</ul></li>
<li><ol start="3" type="i">
<li></li>
</ol>
<ul>
<li>单一 ref 产生类似 ii 的问题， 比如对于 r2，c2 可以说是非常好的翻译，如果没有 r2 仅用 r1 判断，c2 就比 c1 差很多。</li>
</ul></li>
<li><ol start="4" type="i">
<li></li>
</ol></li>
</ul>
<table>
<thead>
<tr class="header">
<th>BLEU vs Human</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pro</td>
<td>Fast</td>
<td>Language independent</td>
</tr>
<tr class="even">
<td>Con</td>
<td>Lack of Common Sense</td>
<td>Need Multiple References</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>CS224N作业笔记</category>
      </categories>
      <tags>
        <tag>CS224N</tag>
      </tags>
  </entry>
  <entry>
    <title>CS224N-Lec15</title>
    <url>/2020/08/24/CS224N-Lec15/</url>
    <content><![CDATA[<h1 id="natural-language-generation">Natural Language Generation</h1>
<h2 id="nlg">NLG</h2>
<ul>
<li>subcomponent of
<ul>
<li>Machine Translation</li>
<li><strong>summarization</strong></li>
<li>dialogue</li>
<li>Freeform question answering(not only from the context)</li>
<li>Image Captioning</li>
</ul></li>
</ul>
<h2 id="recap">Recap</h2>
<ul>
<li><p>Language modeling? the task of predicting the next word: <span class="math display">\[P(y_t|y_1, ..., y_(t-1))\]</span></p></li>
<li><p>Language model</p></li>
<li><p>RNN-LM</p></li>
<li><p>Conditional Language Modeling <span class="math display">\[P(y_t|y_1, ..., y_(t-1), x)\]</span></p>
<ul>
<li>what is x? condition.</li>
<li>Examples:
<ul>
<li>Machine Translation (x = source sentence, y = target sentence)</li>
<li>Summarization (context and summarized)</li>
<li>Dialogue (dialogue history and next utterance)</li>
</ul></li>
</ul></li>
<li><p>training a RNN-LM? <span class="math display">\[J = \dfrac{1}{T}\sum\limits_{t=1}^T J_t\]</span></p>
<ul>
<li>"Teacher Forcing": always use the gold to feed into the decoder</li>
</ul></li>
<li><p><strong>decoding algorithms</strong></p>
<ul>
<li>Greedy decoding: argmax each step</li>
<li>Beam search: aims to find a high prob seq.
<ul>
<li>k most probable partial seqs (hypotheses)</li>
<li>k is the beam size (e.g. 2)</li>
<li>when reaching some stopping criterion, output</li>
<li>what's the effect of changing k?
<ul>
<li>k=1: greedy decoding</li>
<li>larger k: more hypotheses, computationaly expensive
<ul>
<li>for NMT, increasing k too much <strong>decreases</strong> BLEU, reason: producing shorter translations</li>
<li>for chit-chat dialogue, producing too generic responses</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>sampling-based decoding</strong>
<ul>
<li>pure sampling: randomly sample, instead of argmax in greedy</li>
<li>top-n sampling, randomly sample from top-n. truncate. n is another hyperparameter
<ul>
<li>increasing n, diverse and risky</li>
<li>decreasing n, generic and safe</li>
</ul></li>
</ul></li>
<li><strong>Softmax teperature</strong> -- not actually a decoding algorithm, but a technique applied at test time in conjunction with decoding algorithm
<ul>
<li>temperature hypparam <span class="math inline">\(\tau\)</span> to the softmax:</li>
<li>larger <span class="math inline">\(\tau\)</span>: <span class="math inline">\(P_t\)</span> becomes more uniform, more diverse output(probability is spread around vocab)</li>
</ul></li>
</ul></li>
<li><p>Decoding algorithms: summary</p>
<ul>
<li><u> Greedy </u></li>
<li><u> Beam search </u></li>
<li><u> Sampling methods </u></li>
<li><strong><em>Softmax temperature</em></strong></li>
</ul></li>
</ul>
<h2 id="section-2-nlg-tasks-and-neural-approaches">Section 2: NLG tasks and neural approaches</h2>
<h3 id="summarization">Summarization</h3>
<ul>
<li>definition: x -&gt; y, y is shorter and contains main info of x</li>
<li>examples:
<ul>
<li>Gigaword: headline -&gt; headline. sentence compression</li>
<li><strong>LCSTS</strong> (Chinese microblogging), paragraph -&gt; sentence summary</li>
<li>...</li>
</ul></li>
<li>Sentence simplification:
<ul>
<li>different but related</li>
<li>rewrite, simpler &amp; shorter</li>
<li>examples:
<ul>
<li>simple wikipedia</li>
<li>Newsela: news rewriting for children</li>
</ul></li>
</ul></li>
<li>summarization: 2 mains strategies
<ul>
<li>extractive: highlighter</li>
<li>abastractive: writing</li>
</ul></li>
<li>summarization evaluation: <strong>ROUGE</strong>
<ul>
<li><p>like <strong>BLEU</strong>, based on n-gram overlap</p></li>
<li><p>but no brevity penalty</p></li>
<li><p>ROUGE based on recall while BLEU based on precision</p></li>
<li><p>BLEU is a single number combining the precisions for n=1,2,3,4 n-grams</p></li>
<li><p>ROUGE: ROUGE-1/ROUGE-2/ROUGE-L(Largest common subseq overlap)</p></li>
</ul></li>
<li>Neural summarization:
<ul>
<li>seq2seq + attention NMT</li>
<li>Reinforcement learning</li>
</ul></li>
<li>neural: copy mechanism
<ul>
<li>probability of generation and probability of copying</li>
<li>Pgen: hard(0/1) or soft?</li>
<li>Problem:
<ul>
<li>copy too much: extractive to abstractive</li>
<li>bad at overall content selection, if input is long</li>
<li>no overall strategy for selecting content</li>
</ul></li>
</ul></li>
<li>better content selection
<ul>
<li>2 stages: content selection &amp; surface realization</li>
<li>seq2seq+att, mixed, word-level content selection(attention)</li>
<li>but no global content selection strategy</li>
<li>One solution: bottom-up summarization</li>
</ul></li>
<li>Bottom-up summarization
<ul>
<li>content selection stage: neural sequence tagging</li>
<li>masked, attention</li>
</ul></li>
<li>Neural summarization via RL
<ul>
<li>main idea: directly optimize Rouge-L</li>
<li>Better practice(both ROUGE &amp; human judgement): ML&amp;RL</li>
</ul></li>
</ul>
<h3 id="dialogue">Dialogue</h3>
]]></content>
      <categories>
        <category>CS224N</category>
      </categories>
      <tags>
        <tag>CS224N</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHubio</title>
    <url>/2020/08/20/My-New-Post/</url>
    <content><![CDATA[<h2 id="weblink">Weblink:</h2>
<p>知乎专栏<a href="https://zhuanlan.zhihu.com/p/26625249" class="uri">https://zhuanlan.zhihu.com/p/26625249</a>; 大卫博客<a href="https://univeryinli.github.io/about" class="uri">https://univeryinli.github.io/about</a></p>
<h3 id="安装">安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo -g <span class="comment">#安装Hexo</span></span><br><span class="line">npm update hexo -g <span class="comment">#升级</span></span><br><span class="line">hexo init <span class="comment">#初始化博客</span></span><br></pre></td></tr></table></figure>
<h3 id="命令简写">命令简写</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; &#x3D;&#x3D; hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate #生成</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server #启动服务预览</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy #部署</span><br><span class="line"></span><br><span class="line">hexo server #Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line"></span><br><span class="line">刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作</span><br></pre></td></tr></table></figure>
<h3 id="推送网站"><strong>推送网站</strong></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim _config.yml;</span><br><span class="line">   deploy:</span><br><span class="line">   type: git</span><br><span class="line"> repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean </span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h3 id="next-主题">next 主题</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h3 id="配置next">配置next</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure>
<h4 id="新建about页">新建about页</h4>
<p>编辑<code>source/about/index.md</code>, 进入<code>themes/next/_config.yml</code>, <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br></pre></td></tr></table></figure> 再生成部署。</p>
]]></content>
  </entry>
  <entry>
    <title>Uber盈利和经营策略研究</title>
    <url>/2020/08/22/ResearchOnUber/</url>
    <content><![CDATA[<h3 id="提要">提要</h3>
<p>这是 DROM8110 Business Analytics Strategy 的最终报告，运用了 Contributed Value Analysis / Sustainability Analysis 等框架，分析了 Uber 的主营业务——叫车(Ride-Hailing) 的商业模型、盈利前景和可行策略。</p>
<h3 id="其他作者">其他作者:</h3>
<ul>
<li>RUOMING GU (rg3266@columbia.edu)</li>
<li>YUXIN ZHANG (yz3718@columbia.edu)</li>
</ul>
<h3 id="正文">正文:</h3>
<div class="pdfobject-container" data-target="./BAS_FINAL_YAO.pdf" data-height="1000px"></div>
]]></content>
      <categories>
        <category>报告</category>
      </categories>
      <tags>
        <tag>Business Analytics Strategy</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2020/08/24/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="链接">链接：</h1>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247484184&amp;idx=1&amp;sn=62965b401aa42107b3c17d1d8ea17454&amp;chksm=fa0e6c99cd79e58f298e9026f677f912bd8c8e55edb48fc509b2b5834f05e529a9b47d59d202&amp;scene=21#wechat_redirect">十大经典排序算法动画与解析，看我就够了！（配代码完全版）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52884590">视频 | 手撕九大经典排序算法，看我就够了！ - 力扣（LeetCode）的文章 - 知乎</a></p>
<h1 id="复杂度">复杂度</h1>
<figure>
<img src="https://pic2.zhimg.com/v2-b9b0c6526d416d8e8e81916ac1dd63b8_b.jpg" alt="" /><figcaption>复杂度</figcaption>
</figure>
<!-- | Sorting Algorithm | Avg. Time | Best Case  | Worst Case | Space | Inplace | Stability |
| ----------------- | --------- | ---------- | ---------- | ----- | ------- | --------- |
| BubbleSort        | O(n2)     | O(n)       | O(n2)      | O(1)  | Y       | Y         |
| SelectionSort     | O(n2)     | O(n2)      | O(n2)      | O(1)  | Y       | N         |
| InsertSort        | O(n2)     | O(n)       | O(n)       | O(1)  | Y       | N         |
| ShellSort         | O(nlogn)  | O(nlogn) |            | O(1)  | Y       | N         |
| MergeSort         |           |            |            |       | N       |           |
| QuickSort         |           |            |            |       |         |           |
| HeapSort          |           |            |            |       |         |           |
| CountingSort      |           |            |            |       | N       |           |
| BucketSort        |           |            |            |       | N       |           |
| RadixSort         |           |            |            |       | N       |           | -->
<p><a href="https://www.zhihu.com/question/24516934/answer/28076722">很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？ - 曾加的回答 - 知乎</a></p>
<h1 id="排序算法">排序算法</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<p>基础版本： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化版本： 如果第<code>i</code>个循环，从第<code>0</code>个到第<code>arr.length-1-i</code>都顺序，则可以提前结束 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] BubbleSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// 默认存在逆序对，会发生交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//如果全部顺序就提前结束外循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序">选择排序</h2>
<p>每一步找出未排序序列中的最小值 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] SelectionSort(<span class="keyword">int</span>[] sourceArray)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> argmin = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; arr.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[argmin])&#123;</span><br><span class="line">                argmin = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[argmin];</span><br><span class="line">        arr[argmin] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="插入排序">插入排序</h2>
<p>把下一个元素插入到有序序列的合适位置 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] InsertSort(<span class="keyword">int</span>[] sourceArray)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp)&#123;</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="希尔排序">希尔排序</h2>
<p>优化版的插入排序 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length &gt;&gt; <span class="number">1</span>; gap &gt;= <span class="number">1</span>; gap &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j - gap] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="归并排序">归并排序</h2>
<p>递归，如果用原位迭代空间复杂度为o(1)但时间复杂度到o(n2) <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> middle = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;<span class="comment">// 两个有序序列</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result[i] = left[<span class="number">0</span>];</span><br><span class="line">            i++;</span><br><span class="line">            left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i] = right[<span class="number">0</span>];</span><br><span class="line">            i++;</span><br><span class="line">            right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result[i] = left[<span class="number">0</span>];</span><br><span class="line">        i++;</span><br><span class="line">        left = Arrays.copyOfRange(left, <span class="number">1</span>, left.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        result[i] = right[<span class="number">0</span>];</span><br><span class="line">        i++;</span><br><span class="line">        right = Arrays.copyOfRange(right, <span class="number">1</span>, right.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="快速排序">快速排序</h2>
<ul>
<li>快速排序是对冒泡排序的一种改进。</li>
<li>时间复杂度并不固定，如果在最坏情况下（元素刚好是反向的）速度比较慢，达到 O(n^2)（和选择排序一个效率），但是如果在比较理想的情况下时间复杂度 O(nlogn)。</li>
</ul>
<figure>
<img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRiaAY3VU8iaziaYcxAasTdrIu69BOVPYtfvqdvicmlJDS94cG2tjwZhVkdHA/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="" /><figcaption>QuickSort</figcaption>
</figure>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。</li>
<li>如果基准值<code>pivot</code>在最左，从<code>i=index=pivot+1</code>开始，每次遇到比<code>arr[index]</code>小的元素，就<code>swap(arr, i, index); index++</code>。<code>index</code>记录分隔符向右移动的情况，但此时pivot的位置还未改变，直到最后再<code>swap(arr), pivot, index-1</code>。</li>
<li>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> quicksort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] quicksort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123; <span class="comment">// 约束，防止partitionIndex到0</span></span><br><span class="line">        <span class="keyword">int</span> partitionIndex = partition(arr, left, right); <span class="comment">// partition实际执行排序操作</span></span><br><span class="line">        quicksort(arr, left, partitionIndex - <span class="number">1</span>); <span class="comment">// 不含中间</span></span><br><span class="line">        quicksort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partition方法对arr进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = left;</span><br><span class="line">    <span class="keyword">int</span> index = pivot + <span class="number">1</span>; <span class="comment">// 从左端开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index); <span class="comment">// pivot右边一位作为index不断地和后续比arr[pivot]小的元素交换位置，</span></span><br><span class="line">            index++; <span class="comment">// index位向右挪</span></span><br><span class="line">            <span class="comment">// 最终pivot往右直到index-1都是小于基准的，再把pivot放到中间位置index-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<ul>
<li>堆：相较于完全二叉树，所有父节点的值大于（小于）子节点</li>
<li>最大堆的最大元素值出现在根结点（堆顶）</li>
<li>稳定性：不稳定</li>
<li>完全二叉树、二叉堆属于数据结构。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest] )&#123; <span class="comment">//注意次序，先判断index</span></span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest])&#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; largest)&#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//i &gt;= 0</span></span><br><span class="line">        heapify(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] sourceArray)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">    buildMaxHeap(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(arr, <span class="number">0</span>, i); <span class="comment">// 右下子节点和根节点交换，根节点最大值放到最后</span></span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>, len); <span class="comment">//调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序">计数排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] CountingSort(<span class="keyword">int</span>[] sourceArray)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> (countingsort(arr, getMaxValue(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] countingsort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxValue)&#123;</span><br><span class="line">    <span class="keyword">int</span> bucketlen = maxValue + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] bucketarr = <span class="keyword">new</span> <span class="keyword">int</span>[bucketlen];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value: arr)&#123;</span><br><span class="line">        bucketarr[value] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketlen; i++)&#123; <span class="comment">// i &lt; bucketlen</span></span><br><span class="line">        <span class="keyword">while</span> (bucketarr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            arr[sortedIndex++] = i;</span><br><span class="line">            bucketarr[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        maxValue = arr[i] &gt; maxValue ? arr[i] : maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序">桶排序</h2>
<figure>
<img src="https://mmbiz.qpic.cn/mmbiz_gif/D67peceibeISwc3aGibUlvZ0XqVnbWtBRia0umOurgFRv8ESYzcK6bXknufLgJGLaiaTrDTXUk09R6ia2DhbCPAJx0A/640?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="" /><figcaption>BucketSort</figcaption>
</figure>
<ul>
<li>设置固定数量的空桶。</li>
<li>把数据放到对应的桶中</li>
<li>对每个不为空的桶中数据进行排序</li>
<li>拼接不为空的桶中数据，得到结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(sort(a)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶排序主体部分 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            maxValue = value &gt; maxValue ? value : maxValue;</span><br><span class="line">            minValue = value &lt; minValue ? value : minValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">int</span> bucketIndex = (<span class="keyword">int</span>) Math.floor((value - minValue) / bucketSize);</span><br><span class="line">            buckets[bucketIndex] = arrayAppend(buckets[bucketIndex], value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i].length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] bucket = buckets[i];</span><br><span class="line">            bucket = InsertSort(bucket);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">                arr[sortedIndex++] = bucket[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个桶内部用到插入排序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] InsertSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array扩容</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = a;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序">基数排序</h2>
<ul>
<li>首先通过<code>getMaxValue</code>方法得出最大数</li>
<li>通过<code>getDigitCount</code>方法得出最大数的数位数，也就是全arr的最大digits数</li>
<li><code>getDigitValue</code>方法可以给出给定数的某数位的值</li>
<li>从低位（个位）开始，新建0-9十个空桶，按照arr中每个数的个位放入桶中，然后再依次放回到arr中</li>
<li>再进入下一位，新建十个空桶，重复操作</li>
<li>直到遍历MaxDigit</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="comment">// 从个位比较开始数位 (低位)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++) &#123;</span><br><span class="line">            <span class="comment">// 每次比较数位时初始化新的10个空桶</span></span><br><span class="line">            <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">0</span>]; <span class="comment">// 0-9, 10 buckets, each store several values;</span></span><br><span class="line">            <span class="comment">// arr的值进入10个桶</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">                buckets[getDigitValue(value, i)] = arrayAppend(buckets[getDigitValue(value, i)], value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从桶中把值拿出来放回arr</span></span><br><span class="line">            <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// System.out.printf(&quot;buckets[%d]: %s&quot;, j, Arrays.toString(buckets[j]));</span></span><br><span class="line">                <span class="keyword">if</span> (buckets[j].length == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> value : buckets[j]) &#123;</span><br><span class="line">                    arr[sortedIndex++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 个位为第0位</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigitValue</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digitCount = getDigitCount(a);</span><br><span class="line">        <span class="keyword">if</span> (digit &gt; digitCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digit; i++) &#123;</span><br><span class="line">            a /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getDigitCount(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDigitCount</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digitCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a /= <span class="number">10</span>;</span><br><span class="line">            digitCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digitCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            maxValue = value &gt; maxValue ? value : maxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = a;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">9</span>, <span class="number">28</span>, <span class="number">7</span>, <span class="number">345</span>, <span class="number">579</span>, <span class="number">42</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">101</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(sort(a)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>python股票分析</title>
    <url>/2020/09/01/python%E8%82%A1%E7%A5%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1NW411W7FK">【Python学习】股票分析系列（中文自制） by 大力牛肉粉</a></p>
<p><a href="http://data.eastmoney.com/zjlx/detail.html">东方财富网资金流向</a></p>
<p><a href="https://curl.trillworks.com/">Convert curl syntax to Python, Ansible URI, MATLAB, Node.js, R, PHP, Strest, Go, Dart, JSON, Elixir, Rust</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr <span class="comment"># 获取在线数据</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> style <span class="comment"># style</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="获取数据">获取数据</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start = dt.datetime(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">30</span>)</span><br><span class="line">end = dt.datetime(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">df = pdr.get_data_yahoo(<span class="string">&quot;TSLA&quot;</span>, start, end)</span><br><span class="line">df.to_csv(<span class="string">&quot;tsla.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;tsla.csv&quot;</span>, parse_dates=<span class="literal">True</span>, index_col=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">style.use(<span class="string">&quot;ggplot&quot;</span>)</span><br><span class="line"></span><br><span class="line">df.plot(figsize=(<span class="number">16</span>,<span class="number">10</span>),fontsize=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;AxesSubplot:xlabel=&#39;Date&#39;&gt;</code></pre>
<figure>
<img src="pyFinance_files/pyFinance_4_1.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<h1 id="十日均线">十日均线</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;tsla.csv&quot;</span>, parse_dates=<span class="literal">True</span>, index_col=<span class="number">0</span>)</span><br><span class="line">df[<span class="string">&quot;10ma&quot;</span>] = df[<span class="string">&quot;Adj Close&quot;</span>].rolling(window=<span class="number">10</span>, min_periods=<span class="number">0</span>).mean()</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
High
</th>
<th>
Low
</th>
<th>
Open
</th>
<th>
Close
</th>
<th>
Volume
</th>
<th>
Adj Close
</th>
<th>
10ma
</th>
</tr>
<tr>
<th>
Date
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2019-08-30
</th>
<td>
46.487999
</td>
<td>
44.841999
</td>
<td>
45.830002
</td>
<td>
45.122002
</td>
<td>
46603000.0
</td>
<td>
45.122002
</td>
<td>
45.122002
</td>
</tr>
<tr>
<th>
2019-09-03
</th>
<td>
45.790001
</td>
<td>
44.632000
</td>
<td>
44.816002
</td>
<td>
45.001999
</td>
<td>
26770500.0
</td>
<td>
45.001999
</td>
<td>
45.062000
</td>
</tr>
<tr>
<th>
2019-09-04
</th>
<td>
45.692001
</td>
<td>
43.841999
</td>
<td>
45.377998
</td>
<td>
44.136002
</td>
<td>
28805000.0
</td>
<td>
44.136002
</td>
<td>
44.753334
</td>
</tr>
<tr>
<th>
2019-09-05
</th>
<td>
45.959999
</td>
<td>
44.169998
</td>
<td>
44.500000
</td>
<td>
45.916000
</td>
<td>
36976500.0
</td>
<td>
45.916000
</td>
<td>
45.044001
</td>
</tr>
<tr>
<th>
2019-09-06
</th>
<td>
45.928001
</td>
<td>
45.034000
</td>
<td>
45.439999
</td>
<td>
45.490002
</td>
<td>
20947000.0
</td>
<td>
45.490002
</td>
<td>
45.133201
</td>
</tr>
</tbody>
</table>
</div>
<h1 id="ax和subplot">ax和subplot</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># SimHei：微软雅黑</span></span><br><span class="line"><span class="comment"># FangSong：仿宋</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">ax.plot(df.index, df[<span class="string">&quot;Adj Close&quot;</span>])</span><br><span class="line">ax.plot(df.index, df[<span class="string">&quot;10ma&quot;</span>])</span><br><span class="line">ax.legend([<span class="string">&quot;Adj Close&quot;</span>, <span class="string">&quot;10ma&quot;</span>])</span><br><span class="line">ax.set_title(<span class="string">&quot;Adj_Close &amp; 10ma&quot;</span>, fontsize=<span class="number">18</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Date&quot;</span>, fontsize=<span class="number">18</span>, fontfamily = <span class="string">&#x27;DejaVu Sans&#x27;</span>, fontstyle=<span class="string">&quot;italic&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;$&quot;</span>, fontsize = <span class="string">&quot;x-large&quot;</span>, fontstyle=<span class="string">&quot;oblique&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ax.minorticks_on()</span></span><br><span class="line">ax.grid(which=<span class="string">&quot;minor&quot;</span>, axis=<span class="string">&quot;both&quot;</span>)</span><br><span class="line"><span class="comment"># ax.margins(0)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="pyFinance_files/pyFinance_8_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axs = plt.subplots(<span class="number">2</span>, figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line">ax = axs[<span class="number">0</span>]</span><br><span class="line">ax2 = axs[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">ax.plot(df.index, df[<span class="string">&quot;Adj Close&quot;</span>])</span><br><span class="line">ax.plot(df.index, df[<span class="string">&quot;10ma&quot;</span>])</span><br><span class="line">ax.legend([<span class="string">&quot;Adj Close&quot;</span>, <span class="string">&quot;10ma&quot;</span>])</span><br><span class="line">ax.set_title(<span class="string">&quot;Adj_Close &amp; 10ma&quot;</span>)</span><br><span class="line"><span class="comment"># ax.set_xlabel(&quot;Date&quot;,  fontfamily = &#x27;DejaVu Sans&#x27;, fontstyle=&quot;italic&quot;)</span></span><br><span class="line">ax.set_ylabel(<span class="string">&quot;$&quot;</span>, fontstyle=<span class="string">&quot;oblique&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax2.bar(df.index, df[<span class="string">&quot;Volume&quot;</span>])</span><br><span class="line">ax2.set_ylabel(<span class="string">&quot;Volume&quot;</span>, fontstyle=<span class="string">&quot;oblique&quot;</span>)</span><br><span class="line">style.use(<span class="string">&quot;ggplot&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="pyFinance_files/pyFinance_9_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<h1 id="蜡烛图">蜡烛图</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.dates <span class="keyword">as</span> mdates</span><br><span class="line"><span class="keyword">from</span> mpl_finance <span class="keyword">import</span> candlestick_ohlc <span class="comment">#蜡烛图</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&quot;tsla.csv&quot;</span>, parse_dates=<span class="literal">True</span>, index_col=<span class="number">0</span>)</span><br><span class="line">df_ohlc = df[<span class="string">&quot;Adj Close&quot;</span>].resample(<span class="string">&quot;10D&quot;</span>).ohlc() <span class="comment">#open high low close</span></span><br><span class="line">df_volume = df[<span class="string">&quot;Volume&quot;</span>].resample(<span class="string">&quot;10D&quot;</span>).sum()</span><br><span class="line">df_ohlc.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">df_ohlc.Date = df_ohlc.Date.map(mdates.date2num)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">16</span>,<span class="number">10</span>))</span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">6</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">0</span>), rowspan=<span class="number">5</span>, colspan=<span class="number">1</span>)</span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">6</span>,<span class="number">1</span>), (<span class="number">5</span>,<span class="number">0</span>), rowspan=<span class="number">1</span>, colspan=<span class="number">1</span>, sharex = ax1)</span><br><span class="line"></span><br><span class="line">ax1.xaxis_date()</span><br><span class="line">candlestick_ohlc(ax1, df_ohlc.values, width=<span class="number">5</span>, colorup=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">ax2.fill_between(df_volume.index.map(mdates.date2num), df_volume.values, <span class="number">0</span>)</span><br><span class="line">ax2.plot(df_volume)</span><br><span class="line"></span><br><span class="line">style.use(<span class="string">&quot;ggplot&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure>
<img src="pyFinance_files/pyFinance_13_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<h1 id="标普500公司简称获取爬虫">标普500公司简称获取(爬虫)</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs <span class="comment"># 字典</span></span><br><span class="line"><span class="keyword">import</span> pickle <span class="comment"># 列表，序列化</span></span><br><span class="line"><span class="keyword">import</span> requests <span class="comment"># 网络请求</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_sp500_tickers</span>():</span></span><br><span class="line">    resp = requests.get(<span class="string">&quot;https://en.wikipedia.org/wiki/List_of_S%26P_500_companies&quot;</span>)</span><br><span class="line">    soup = bs(resp.text, <span class="string">&quot;lxml&quot;</span>)</span><br><span class="line">    table = soup.find(<span class="string">&quot;table&quot;</span>, &#123;<span class="string">&quot;class&quot;</span>:<span class="string">&quot;wikitable sortable&quot;</span>&#125;)</span><br><span class="line">    tickers = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> table.findAll(<span class="string">&#x27;tr&#x27;</span>)[<span class="number">1</span>:]:</span><br><span class="line">        ticker = row.findAll(<span class="string">&#x27;td&#x27;</span>)[<span class="number">0</span>].text.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        tickers.append(ticker)</span><br><span class="line">    <span class="comment"># print(tickers)</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;sp500tickers.pickle&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f: <span class="comment"># 二进制只读</span></span><br><span class="line">        pickle.dump(tickers, f)</span><br><span class="line">    <span class="keyword">return</span> tickers</span><br><span class="line">        </span><br><span class="line"><span class="comment"># save_sp500_tickers()</span></span><br></pre></td></tr></table></figure>
<h1 id="下载sp500股票数据">下载SP500股票数据</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os <span class="comment"># 系统接口</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> datetime <span class="keyword">as</span> dt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data_from_yahoo</span>(<span class="params">isReload=False</span>):</span></span><br><span class="line">    <span class="keyword">if</span> isReload:</span><br><span class="line">        tickers = save_sp500_tickers()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&quot;sp500tickers.pickle&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            tickers = pickle.load(f)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;stock_dfs&quot;</span>): <span class="comment">#当前目录无该子目录</span></span><br><span class="line">        os.makedirs(<span class="string">&quot;stock_dfs&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    start = dt.datetime(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    end = dt.datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ticker <span class="keyword">in</span> tickers:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;stock_dfs/&#123;&#125;.csv&quot;</span>.format(ticker)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                df = pdr.get_data_yahoo(ticker, start, end)</span><br><span class="line">                df.to_csv(<span class="string">&quot;stock_dfs/&#123;&#125;.csv&quot;</span>.format(ticker))</span><br><span class="line">                print(<span class="string">&quot;Download complete: &#123;&#125;&quot;</span>.format(ticker))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;Already exist: &#123;&#125;&quot;</span>.format(ticker))</span><br><span class="line">    </span><br><span class="line">get_data_from_yahoo(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h1 id="整合数据">整合数据</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile_data</span>():</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;sp500tickers.pickle&quot;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        tickers = pickle.load(f)[:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">    main_df = pd.DataFrame()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compile</span></span><br><span class="line">    <span class="keyword">for</span> count, ticker <span class="keyword">in</span> enumerate(tickers):</span><br><span class="line">        df = pd.read_csv(<span class="string">&quot;stock_dfs/&#123;&#125;.csv&quot;</span>.format(ticker))</span><br><span class="line">        df.set_index(<span class="string">&quot;Date&quot;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        df.rename(columns = &#123;<span class="string">&quot;Adj Close&quot;</span>: ticker&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">        df.drop([<span class="string">&quot;Open&quot;</span>, <span class="string">&quot;High&quot;</span>, <span class="string">&quot;Low&quot;</span>, <span class="string">&quot;Close&quot;</span>, <span class="string">&quot;Volume&quot;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> main_df.empty:</span><br><span class="line">            main_df = df</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            main_df = main_df.join(df, how=<span class="string">&quot;left&quot;</span>)</span><br><span class="line">        print(count)</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    main_df.to_csv(<span class="string">&quot;sp500_joined.csv&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> main_df</span><br><span class="line"></span><br><span class="line">main_df = compile_data()</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
4
5
6
7
8
9</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main_df</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
MMM
</th>
<th>
ABT
</th>
<th>
ABBV
</th>
<th>
ABMD
</th>
<th>
ACN
</th>
<th>
ATVI
</th>
<th>
ADBE
</th>
<th>
AMD
</th>
<th>
AAP
</th>
<th>
AES
</th>
</tr>
<tr>
<th>
Date
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
<th>
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
2016-01-04
</th>
<td>
128.033249
</td>
<td>
39.050327
</td>
<td>
46.141216
</td>
<td>
85.239998
</td>
<td>
93.774796
</td>
<td>
36.365803
</td>
<td>
91.970001
</td>
<td>
2.770000
</td>
<td>
150.250793
</td>
<td>
7.769172
</td>
</tr>
<tr>
<th>
2016-01-05
</th>
<td>
128.591339
</td>
<td>
39.041222
</td>
<td>
45.948997
</td>
<td>
85.000000
</td>
<td>
94.262863
</td>
<td>
35.901806
</td>
<td>
92.339996
</td>
<td>
2.750000
</td>
<td>
149.224380
</td>
<td>
7.876278
</td>
</tr>
<tr>
<th>
2016-01-06
</th>
<td>
126.001358
</td>
<td>
38.713760
</td>
<td>
45.956993
</td>
<td>
85.300003
</td>
<td>
94.078682
</td>
<td>
35.563477
</td>
<td>
91.019997
</td>
<td>
2.510000
</td>
<td>
145.276642
</td>
<td>
7.604397
</td>
</tr>
<tr>
<th>
2016-01-07
</th>
<td>
122.931786
</td>
<td>
37.785950
</td>
<td>
45.820843
</td>
<td>
81.919998
</td>
<td>
91.316017
</td>
<td>
35.060810
</td>
<td>
89.110001
</td>
<td>
2.280000
</td>
<td>
146.885345
</td>
<td>
7.414905
</td>
</tr>
<tr>
<th>
2016-01-08
</th>
<td>
122.513206
</td>
<td>
36.994564
</td>
<td>
44.571400
</td>
<td>
84.580002
</td>
<td>
90.431938
</td>
<td>
34.519478
</td>
<td>
87.849998
</td>
<td>
2.140000
</td>
<td>
143.658066
</td>
<td>
7.522010
</td>
</tr>
<tr>
<th>
...
</th>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
<td>
...
</td>
</tr>
<tr>
<th>
2018-12-24
</th>
<td>
168.035690
</td>
<td>
63.701054
</td>
<td>
75.395958
</td>
<td>
281.079987
</td>
<td>
130.427887
</td>
<td>
43.354313
</td>
<td>
205.160004
</td>
<td>
16.650000
</td>
<td>
147.761047
</td>
<td>
13.031178
</td>
</tr>
<tr>
<th>
2018-12-26
</th>
<td>
175.222961
</td>
<td>
67.645943
</td>
<td>
79.767776
</td>
<td>
307.440002
</td>
<td>
135.638382
</td>
<td>
45.749195
</td>
<td>
222.949997
</td>
<td>
17.900000
</td>
<td>
153.823486
</td>
<td>
13.464924
</td>
</tr>
<tr>
<th>
2018-12-27
</th>
<td>
179.399902
</td>
<td>
68.627304
</td>
<td>
80.547180
</td>
<td>
315.670013
</td>
<td>
137.004425
</td>
<td>
46.360237
</td>
<td>
225.139999
</td>
<td>
17.490000
</td>
<td>
153.486160
</td>
<td>
13.474353
</td>
</tr>
<tr>
<th>
2018-12-28
</th>
<td>
178.148697
</td>
<td>
69.074249
</td>
<td>
81.631172
</td>
<td>
318.170013
</td>
<td>
136.428741
</td>
<td>
46.123703
</td>
<td>
223.130005
</td>
<td>
17.820000
</td>
<td>
154.250168
</td>
<td>
13.455495
</td>
</tr>
<tr>
<th>
2018-12-31
</th>
<td>
179.249359
</td>
<td>
70.279106
</td>
<td>
82.589752
</td>
<td>
325.040009
</td>
<td>
137.589874
</td>
<td>
45.897026
</td>
<td>
226.240005
</td>
<td>
18.459999
</td>
<td>
156.234573
</td>
<td>
13.634648
</td>
</tr>
</tbody>
</table>
<p>
754 rows × 10 columns
</p>
</div>
<h1 id="数据可视化">数据可视化</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 股票相关度？</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_data</span>():</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&quot;sp500_joined.csv&quot;</span>)</span><br><span class="line">    df_corr = df.corr()</span><br><span class="line">    df_corr.to_csv(<span class="string">&quot;sp500corr.csv&quot;</span>)</span><br><span class="line">    data1 = df_corr.values</span><br><span class="line">    fig1 = plt.figure()</span><br><span class="line">    ax1 = fig1.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    heatmap1 = ax1.pcolor(data1, cmap=plt.cm.RdYlGn)</span><br><span class="line">    fig1.colorbar(heatmap1)</span><br><span class="line"></span><br><span class="line">    ax1.set_xticks(np.arange(data1.shape[<span class="number">1</span>]))</span><br><span class="line">    ax1.set_yticks(np.arange(data1.shape[<span class="number">0</span>]))</span><br><span class="line">    ax1.invert_yaxis()</span><br><span class="line">    ax1.xaxis.tick_top()</span><br><span class="line">    column_labels = df_corr.columns</span><br><span class="line">    row_labels = df_corr.index</span><br><span class="line">    ax1.set_xticklabels(column_labels)</span><br><span class="line">    ax1.set_yticklabels(row_labels)</span><br><span class="line">    plt.xticks(rotation=<span class="number">90</span>)</span><br><span class="line">    heatmap1.set_clim(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">visualize_data()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="pyFinance_files/pyFinance_24_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 股票相关度？</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_data</span>():</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&quot;sp500_joined.csv&quot;</span>)</span><br><span class="line">    df_corr = df.corr()</span><br><span class="line">    df_corr.to_csv(<span class="string">&quot;sp500corr.csv&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    f, axes = plt.subplots(<span class="number">1</span>, figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">    <span class="comment"># sns.set(style=&quot;whitegrid&quot;)</span></span><br><span class="line">    sns.despine(left=<span class="literal">True</span>)</span><br><span class="line">    sns.heatmap(df_corr, cmap= <span class="string">&quot;RdYlGn&quot;</span>, cbar=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">visualize_data()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img src="pyFinance_files/pyFinance_26_0.svg" alt="" /><figcaption>svg</figcaption>
</figure>
<h1 id="获取7日内股价波动">获取7日内股价波动</h1>
<ul>
<li>买/卖/持有？</li>
<li>7日内表现</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_data_for_labels</span>(<span class="params">ticker</span>):</span></span><br><span class="line">    hm_days = <span class="number">7</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&quot;sp500_joined.csv&quot;</span>, index_col=<span class="number">0</span>)</span><br><span class="line">    tickers = df.columns.values.tolist()</span><br><span class="line">    df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, hm_days+<span class="number">1</span>):</span><br><span class="line">        df[<span class="string">&quot;&#123;&#125;_&#123;&#125;d&quot;</span>.format(ticker, i)] = (df[ticker].shift(-i)-df[ticker])/df[ticker]</span><br><span class="line">    df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> tickers, df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy_sell_hold</span>(<span class="params">*args</span>):</span></span><br><span class="line">    cols = [c <span class="keyword">for</span> c <span class="keyword">in</span> args]</span><br><span class="line">    requirement = <span class="number">0.02</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">        <span class="keyword">if</span> col &gt; requirement:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> col &lt; -requirement:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1 id="获取特征集合">获取特征集合</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_featuresets</span>(<span class="params">ticker</span>):</span></span><br><span class="line">    tickers, df = process_data_for_labels(ticker)</span><br><span class="line">    df[<span class="string">&quot;&#123;&#125;_target&quot;</span>.format(ticker)] = list(map(buy_sell_hold, </span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_1d&quot;</span>.format(ticker)],</span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_2d&quot;</span>.format(ticker)],</span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_3d&quot;</span>.format(ticker)],</span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_4d&quot;</span>.format(ticker)],</span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_5d&quot;</span>.format(ticker)],</span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_6d&quot;</span>.format(ticker)],</span><br><span class="line">                                    df[<span class="string">&quot;&#123;&#125;_7d&quot;</span>.format(ticker)],</span><br><span class="line">                                    ))</span><br><span class="line"></span><br><span class="line">    vals = df[<span class="string">&quot;&#123;&#125;_target&quot;</span>.format(ticker)].values.tolist()</span><br><span class="line">    str_vals = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> vals]</span><br><span class="line">    <span class="comment"># print(&quot;Data spread&quot;, Counter(str_vals))</span></span><br><span class="line"></span><br><span class="line">    df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    df.replace([np.inf, -np.inf], np.nan, inplace=<span class="literal">True</span>)</span><br><span class="line">    df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    df_vals = df[[t <span class="keyword">for</span> t <span class="keyword">in</span> tickers]].pct_change() <span class="comment"># 环比</span></span><br><span class="line">    df_vals.replace([np.inf, -np.inf], np.nan)</span><br><span class="line">    df_vals.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    X = df_vals.values</span><br><span class="line">    y = df[<span class="string">f&quot;<span class="subst">&#123;ticker&#125;</span>_target&quot;</span>].values</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X, y, df</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="机器学习">机器学习</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X, y, _ = extract_featuresets(<span class="string">&quot;MMM&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm, neighbors <span class="comment">#cross_validation deprecated </span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> VotingClassifier, RandomForestClassifier<span class="comment"># 综合不同算法</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_ml</span>(<span class="params">ticker</span>):</span></span><br><span class="line">    X,y,df</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/09/02/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="链接">链接</h2>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485570&amp;idx=2&amp;sn=7a4e2635aafcf1c9bd01642f6cedd409&amp;chksm=fa0e6703cd79ee15f692f31c488aac6787a08ffea2ffe457a037310df355c1e6a810919333e4&amp;scene=21#wechat_redirect">二分查找算法详解</a></p>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">binarysearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(right_bound(a, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认数组有序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == arr[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找左侧边界</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == arr.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (arr[left] == target) ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找右侧边界</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (arr[left - <span class="number">1</span>] == target) ? left - <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点">注意点</h3>
<ol type="1">
<li>确定左右边界时, 初始区间[0, arr.length)。</li>
<li>确定左边界时, 关键在于</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">    right = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是由于每次mid的判断将<code>[Left, right)</code> 分成两部分, 这样可以逐次剥除最右的等于target的元素</p>
<ol start="3" type="1">
<li>确定右边界时,</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr[mid] == target)&#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如果剥除最左的等于target的元素，由于区间左闭，需要去除mid。</p>
]]></content>
      <categories>
        <category>Java数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>链表题(持续更新)</title>
    <url>/2020/09/02/%E9%93%BE%E8%A1%A8%E9%A2%98-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="链表类listnode定义"><a class="markdownIt-Anchor" href="#链表类listnode定义"></a> 链表类<code>ListNode</code>定义</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] toArray(ListNode head)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arr = Arrays.copyOf(arr, arr.length+<span class="number">1</span>);</span><br><span class="line">            arr[arr.length-<span class="number">1</span>] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">fromArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode ll = <span class="keyword">new</span> ListNode(arr[<span class="number">0</span>]);</span><br><span class="line">        ListNode head = ll;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            ll.next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">            ll = ll.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>提供了导入导出为数组的内置静态方法。</p>
<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
<h3 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h3>
<p>题目描述：输入一个链表，反转链表后，输出新链表的表头。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev, curr, next, result;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        curr = head;</span><br><span class="line">        result = curr;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            result = curr;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode prev, curr, next;</span><br><span class="line">    prev = <span class="keyword">null</span>; curr = head; </span><br><span class="line">    <span class="keyword">while</span>(curr != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = curr.next;</span><br><span class="line">        curr.next= prev; </span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表有环"><a class="markdownIt-Anchor" href="#链表有环"></a> 链表有环</h3>
<p>题目描述：判断给定的链表中是否有环<br />
扩展：你能给出空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的解法么？</p>
<p>解法: 快慢指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast, slow;</span><br><span class="line">        fast = head;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并有序列表"><a class="markdownIt-Anchor" href="#合并有序列表"></a> 合并有序列表</h3>
<p>题目描述：将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的</p>
<p>解法: 类似归并排序的思路</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LL</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span> <span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize </span></span><br><span class="line">        ListNode last;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            last = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode result = last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// System.out.printf(&quot;l1.val &#123;%d&#125;, l2.val &#123;%d&#125;\n&quot;, l1.val, l2.val);</span></span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">                last.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// System.out.printf(&quot;l1.val &#123;%d&#125;\n&quot;, l1.val);</span></span><br><span class="line">            last.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// System.out.printf(&quot;l2.val &#123;%d&#125;\n&quot;, l2.val);</span></span><br><span class="line">            last.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            last = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a2 = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ListNode l1 = ListNode.fromArray(a1);</span><br><span class="line">        ListNode l2 = ListNode.fromArray(a2);</span><br><span class="line">        ListNode merged = mergeTwoLists(l1, l2);</span><br><span class="line">        System.out.println(Arrays.toString(ListNode.toArray(merged)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="97删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#97删除链表的倒数第n个节点"></a> (9.7)删除链表的倒数第n个节点</h3>
<p>题目描述：</p>
<ul>
<li>
<p>给定一个链表，删除链表的倒数第n个节点并返回链表的头指针</p>
</li>
<li>
<p>例如，<br />
给出的链表为:1-&gt;2-&gt;3-&gt;4-&gt;5, n= 2.<br />
删除了链表的倒数第n个节点之后,链表变为1-&gt;2-&gt;3-&gt;5.</p>
</li>
<li>
<p>备注：题目保证n一定是有效的</p>
</li>
<li>
<p>请给出时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的算法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode prev, curr, next;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除head</span></span><br><span class="line">    <span class="keyword">if</span> (n == len) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curr = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = curr.next;</span><br><span class="line">    next = curr.next;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="97两个链表生成相加链表"><a class="markdownIt-Anchor" href="#97两个链表生成相加链表"></a> (9.7)两个链表生成相加链表</h3>
<p>题目描述：</p>
<ul>
<li>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。</li>
<li>给定两个这种链表，请生成代表两个整数相加值的结果链表。</li>
<li>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</li>
</ul>
<p>分析：</p>
<p>用到了之前的<strong>反转链表</strong>，以及数组相加的策略（进位）。链表增加结点需要考虑初始化的情况。最重要的还是确定哪一步同步current和result两个链表。<br />
讨论区反映java卡75%算例，超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">addInList0907</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addInList</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode head1Rev = reverseList(head1);</span><br><span class="line">        ListNode head2Rev = reverseList(head2);</span><br><span class="line">        ListNode mergeRevCurr = <span class="keyword">null</span>;</span><br><span class="line">        ListNode mergeRev = mergeRevCurr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cache = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> init = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head1Rev != <span class="keyword">null</span> &amp;&amp; head2Rev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            digit = head1Rev.val + head2Rev.val + cache;</span><br><span class="line">            <span class="keyword">if</span> (digit &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                digit -= <span class="number">10</span>;</span><br><span class="line">                cache = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode currDigit = <span class="keyword">new</span> ListNode(digit);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (init) &#123;</span><br><span class="line">                init = <span class="keyword">false</span>;</span><br><span class="line">                mergeRevCurr = currDigit; <span class="comment">// 这一步同步</span></span><br><span class="line">                mergeRev = mergeRevCurr;</span><br><span class="line">                <span class="comment">// System.out.println(Arrays.toString(ListNode.toArray(mergeRev)));</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeRevCurr.next = currDigit;</span><br><span class="line">                mergeRevCurr = mergeRevCurr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head1Rev = head1Rev.next;</span><br><span class="line">            head2Rev = head2Rev.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head1Rev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            digit = head1Rev.val + cache;</span><br><span class="line">            <span class="keyword">if</span> (digit &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                digit -= <span class="number">10</span>;</span><br><span class="line">                cache = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode currDigit = <span class="keyword">new</span> ListNode(digit);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                mergeRevCurr = currDigit;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeRevCurr.next = currDigit;</span><br><span class="line">                mergeRevCurr = mergeRevCurr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head1Rev = head1Rev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head2Rev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            digit = head2Rev.val + cache;</span><br><span class="line">            <span class="keyword">if</span> (digit &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                digit -= <span class="number">10</span>;</span><br><span class="line">                cache = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cache = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode currDigit = <span class="keyword">new</span> ListNode(digit);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                mergeRevCurr = currDigit;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                mergeRevCurr.next = currDigit;</span><br><span class="line">                mergeRevCurr = mergeRevCurr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head2Rev = head2Rev.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(Arrays.toString(ListNode.toArray(mergeRev)));</span></span><br><span class="line">            ListNode currDigit = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            mergeRevCurr.next = currDigit;</span><br><span class="line">            mergeRevCurr = mergeRevCurr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseList(mergeRev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev, curr, next;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = ListNode.fromArray(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>,</span><br><span class="line">                <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        ListNode l2 = ListNode.fromArray(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>,</span><br><span class="line">                <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span> &#125;);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(ListNode.toArray(reverseList(l1))));</span></span><br><span class="line">        System.out.println(Arrays.toString(ListNode.toArray(addInList(l2, l1))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="914-链表中环的入口节点"><a class="markdownIt-Anchor" href="#914-链表中环的入口节点"></a> (9/14) 链表中环的入口节点</h3>
<p>题目描述</p>
<ul>
<li>对于一个给定的链表，返回环的入口节点，如果没有环，返回null</li>
</ul>
<p>解题思路</p>
<ul>
<li>首先用快慢指针判断是否存在环</li>
<li>如存在环，假设环前长度为 d , 环长度为 l , 相遇点在环入口后 s 处</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>+</mo><mi>l</mi><mo>+</mo><mi>s</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>d</mi><mo>+</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d+l+s = 2*(d+s) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>+</mo><mi>s</mi><mo>=</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">d+s = l 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></span></p>
<ul>
<li>快指针归零，再走 (l-s)</li>
<li>慢指针</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>+</mo><mi>s</mi><mo>+</mo><mo stretchy="false">(</mo><mi>l</mi><mo>−</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mo>+</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">d+s+(l-s)=d+l 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></span></p>
<ul>
<li>快指针</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>−</mo><mi>s</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">l-s = d
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></span></p>
<ul>
<li>二者在 d 处相遇</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NowCoder_DetectCycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = head;</span><br><span class="line">        ListNode meetpoint = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr1 != <span class="keyword">null</span> &amp;&amp; ptr1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ptr1 = ptr1.next.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">            <span class="keyword">if</span> (ptr2 == ptr1)&#123;</span><br><span class="line">                meetpoint = ptr1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否有环</span></span><br><span class="line">        <span class="keyword">if</span> (meetpoint == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 快指针从头出发，慢指针接着走</span></span><br><span class="line">        ptr1 = head;</span><br><span class="line">        <span class="keyword">while</span>(ptr1 != ptr2)&#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ListNode l1 = ListNode.fromArray(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;);</span><br><span class="line">        l1.next.next.next.next.next = l1.next.next;</span><br><span class="line">        ListNode l2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        System.out.println(detectCycle(l2).val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="914-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#914-两个链表的第一个公共节点"></a> (9/14) 两个链表的第一个公共节点</h3>
<p>题目描述</p>
<ul>
<li>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</li>
</ul>
<p>解题思路1——<strong>链表成环</strong></p>
<ul>
<li>两链表应该呈现出 “Y” 形。把第二个链表接到第一个链表尾巴上形成一个环，若存在公共节点，则必形成环。</li>
<li>如果保留 p1, 最后的节点 temp -&gt; p2。用 detectCycle(p1) 找出节点 result。<strong>再将temp -&gt; p2 断开</strong>。返回result。</li>
<li>代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ListNode curr = pHead1;</span><br><span class="line">    <span class="keyword">while</span> (curr.next != <span class="keyword">null</span>) curr = curr.next;</span><br><span class="line">    curr.next = pHead2;</span><br><span class="line">    <span class="comment">// 把两个链表接起来找第一个</span></span><br><span class="line"></span><br><span class="line">    ListNode firstCommon = detectCycle(pHead1);</span><br><span class="line">    <span class="comment">// 断开两个链表</span></span><br><span class="line">    curr.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> firstCommon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode ptr1 = head;</span><br><span class="line">    ListNode ptr2 = head;</span><br><span class="line">    ListNode meetpoint = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 != <span class="keyword">null</span> &amp;&amp; ptr1.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ptr1 = ptr1.next.next;</span><br><span class="line">        ptr2 = ptr2.next;</span><br><span class="line">        <span class="keyword">if</span> (ptr2 == ptr1)&#123;</span><br><span class="line">            meetpoint = ptr1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (meetpoint == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 快指针从头出发，慢指针接着走</span></span><br><span class="line">    ptr1 = head;</span><br><span class="line">    <span class="keyword">while</span>(ptr1 != ptr2)&#123;</span><br><span class="line">        ptr1 = ptr1.next;</span><br><span class="line">        ptr2 = ptr2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解题思路2</p>
<ul>
<li>先遍历两链表，分别得出长度</li>
<li>较长者截取掉更长的部分，因为共同部分肯定比较短的链表更短</li>
<li>然后两链表同时向后遍历直到二者相同</li>
<li>代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解法：截取长度并依次比较。复杂度O(m+n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = pHead1;</span><br><span class="line">    ListNode p2 = pHead2;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        len1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        len2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt;= len2)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)&#123;</span><br><span class="line">            pHead1 = pHead1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)&#123;</span><br><span class="line">            pHead2 = pHead2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pHead1 != pHead2)&#123;</span><br><span class="line">        pHead1 = pHead1.next;</span><br><span class="line">        pHead2 = pHead2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pHead1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>分治</title>
    <url>/2020/09/03/%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485228&amp;idx=1&amp;sn=9f48aee51dcb2b98b56b1827cc658439&amp;chksm=fa0e68adcd79e1bbcd0183ef30a79ede4e46c5835ce05ee6644169c3cc9454073019ccd85d3d&amp;scene=21#wechat_redirect">浅谈分治算法</a></p>
<h2 id="使用场景">使用场景</h2>
<p>可以分解为若干 MECE 的相同子问题，即具有最优子结构</p>
<h2 id="步骤">步骤</h2>
<ol type="1">
<li>分解</li>
<li>求解：直接/递归</li>
<li>合并</li>
</ol>
<h2 id="案例">案例</h2>
<h3 id="二分查找基本">二分查找(基本)</h3>
<ul>
<li>算法流程：
<ul>
<li>选择一个标志位 i 将集合分为两个子集合</li>
<li>判断 <code>arr[i]</code> 和 <code>target</code> 关系，相等则返回</li>
<li>否则判断在左侧还是右侧查找</li>
<li>递归直到找到或退出</li>
</ul></li>
<li>代码： <a href="https://hy2632.github.io/2020/09/02/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">二分查找</a></li>
</ul>
<h3 id="全排列问题">全排列问题</h3>
<ul>
<li>问题描述：
<ul>
<li>有1，2，3，4个数，问你有多少种排列方法，并输出排列。</li>
</ul></li>
<li>问题分析：
<ul>
<li>确定第一位后，对后续序列进行全排列。直到只有一个数字时停止。</li>
</ul></li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        fullSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fullSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.prinln();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            swap(arr, i, start);</span><br><span class="line">            fullSort(arr, start + <span class="number">1</span>, end); <span class="comment">// 把该位放到开头，对剩下的位数全排列</span></span><br><span class="line">            swap(arr, i, start;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="归并排序">归并排序</h3>
<ul>
<li>问题分析：
<ul>
<li>一个序列从中点分为两个有序子序列，然后合并。</li>
</ul></li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">guibing</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] sourceArray)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceArray.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> sourceArray;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">int</span> mid = arr.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(arr, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(arr, mid, arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a1 &amp; a2 are both sorted</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a1, <span class="keyword">int</span>[] a2)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[a1.length + a2.length];</span><br><span class="line">        <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; a1.length &amp;&amp; j &lt; a2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a1[i] &lt;= a2[j])&#123;</span><br><span class="line">                result[sortedIndex++] = a1[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[sortedIndex++] = a2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; a1.length)&#123;</span><br><span class="line">            result[sortedIndex++] = a1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; a2.length)&#123;</span><br><span class="line">            result[sortedIndex++] = a2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">76</span>,<span class="number">4</span>,<span class="number">32</span>,<span class="number">643</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(mergeSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<ul>
<li>问题分析：
<ul>
<li>partition: 一个序列，选定一个 pivot ，调整 pivot 位置使得它左边的值小于它，右边的值大于它，并确定该 pivot 的位置</li>
<li>对于左右的序列分别进行快速排序</li>
</ul></li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kuaipai</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] sourceArray) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> quickSortRecursion(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] quickSortRecursion(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = partition(arr, left, right);</span><br><span class="line">            quickSortRecursion(arr, left, mid - <span class="number">1</span>);</span><br><span class="line">            quickSortRecursion(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = left;</span><br><span class="line">        <span class="keyword">int</span> index = pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">3</span>, <span class="number">76</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="number">643</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(quickSort(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔">汉诺塔</h3>
<ul>
<li>问题分析：
<ul>
<li>原问题：n 个盘子，从 source 到 target ，中途可借助 temp</li>
<li>子问题：上面 n-1 个盘子放到temp，最底下盘子到target，然后 temp 上的 n-1 个盘子借助 source 移到 target 上。 如果 n = 1， 直接移。</li>
</ul></li>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, String source, String temp, String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        move (n, source, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hanoi (n - <span class="number">1</span>, source, target, temp);</span><br><span class="line">        move (n, source, target);</span><br><span class="line">        hanoi (n - <span class="number">1</span>, temp, source, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, String source, String target)</span></span>&#123;</span><br><span class="line">    System.out.printf(<span class="string">&quot;第 %d 号盘子 move: %s ---&gt; %s \n&quot;</span>, n, source, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>09/06 论文笔记</title>
    <url>/2020/09/06/09-06-%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="deep-visual-semantic-alignments-for-generating-image-descriptions"><a href="https://cs.stanford.edu/people/karpathy/cvpr2015.pdf"><strong>Deep Visual-Semantic Alignments for Generating Image Descriptions</strong></a></h2>
<p>摘要</p>
<ul>
<li>图像 CNN，文本 BiRNN，multimodal embedding，alignment model</li>
</ul>
<p>介绍部分</p>
<ul>
<li>先前：给定categories的labeling</li>
<li>目标：生成images的dense description</li>
<li>要求：模型同时推断内容和找出自然语言的表示，并且通过训练获得</li>
<li>数据集的challenge：image captioning的数据集并不包含图片中实体的定位</li>
<li>core insight: 句子作为weak labels，句子和图像的定位都未知 -&gt; 模型需要推断位置的 latent alignment</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/09/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<h3 id="买卖股票的最佳时机">(0908)买卖股票的最佳时机</h3>
<p>知识点：数组，动态规划</p>
<p>难度：简单</p>
<p>题目描述：</p>
<ul>
<li>假设你有一个数组，其中第 i 个元素是股票在第 i 天的价格。</li>
<li>你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益。</li>
<li>示例1</li>
<li>输入 [1,4,2]</li>
<li>输出 3</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buy = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        buy = Math.max(buy, -prices[i]);</span><br><span class="line">        sell = Math.max(sell, prices[i] + buy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带权值的最小路径和">(0908)带权值的最小路径和</h3>
<p>知识点：数组，动态规划（矩阵）</p>
<p>难度：中等</p>
<p>题目描述：</p>
<ul>
<li>给定一个由非负整数填充的m x n的二维数组，现在要从二维数组的左上角走到右下角，请找出路径上的所有数字之和最小的路径。注意：你每次只能向下或向右移动。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">    <span class="keyword">int</span> columns = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows + <span class="number">1</span>][columns + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rows; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= columns; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i + <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[rows][columns];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子数组的最大累加和">(0909)子数组的最大累加和</h3>
<ul>
<li><p>知识点：分治，动态规划</p></li>
<li><p>难度：简单</p></li>
<li><p>题目描述：</p>
<ul>
<li>给定一个数组arr，返回子数组的最大累加和</li>
<li>例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.</li>
<li>要求时间复杂度为<span class="math inline">\(O(n)\)</span>，空间复杂度为<span class="math inline">\(O(1)\)</span></li>
</ul></li>
<li><p>理解：问题分为：到某一位为止的最优累加和，和整个数列不同位置为终点的累加和中的最大值(max)。</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxsumofSubarray</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> currSum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (currSum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            currSum = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currSum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum = currSum &gt; maxSum ? currSum : maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lis最长递增子序列现解法超时">(0911)LIS最长递增子序列（现解法超时）</h3>
<ul>
<li><p>知识点：<strong>二分</strong>，动态规划</p></li>
<li><p>难度：中等</p></li>
<li><p>题目描述：</p>
<ul>
<li>给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）</li>
</ul></li>
<li><p>目前解法：</p>
<ul>
<li><code>arrayCompare</code>: 先比较长度，再比较字典序</li>
<li><code>DP[length]</code>: 逐步更新，长度为length的所有子序列中最优解</li>
<li>从arr第一位到最后一位，每次检查<strong>以当前位为最后一位</strong>的最长递增子序列</li>
<li>检查的方法<code>searchInsert</code>：对之前的所有<code>DP[length] (1&lt;=length&lt;=maxlength)</code>遍历，插入当前位<code>arr[i]</code>并舍去大于当前位的部分。这部分用到<code>二分查找</code>。</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NowCoder_LIS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] LIS(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] DP = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][];</span><br><span class="line">        <span class="comment">// 括号内表示LIS长度</span></span><br><span class="line">        DP[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">        DP[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; arr[<span class="number">0</span>] &#125;;</span><br><span class="line">        <span class="keyword">int</span> maxlength = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bestarr = DP[maxlength];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bestarr = searchInsert(DP[maxlength], arr[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = maxlength-<span class="number">1</span>; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                bestarr = arrayCompare(bestarr, searchInsert(DP[j], arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            DP[bestarr.length] = bestarr;</span><br><span class="line">            <span class="keyword">if</span> (bestarr.length &gt; maxlength) maxlength=bestarr.length;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]: %d, DP[%d] : %s \n&quot;</span>, i, arr[i], maxlength, Arrays.toString(DP[maxlength]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DP[maxlength];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arrayCompare(<span class="keyword">int</span>[] a1, <span class="keyword">int</span>[] a2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1.length != a2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> a1.length &gt; a2.length ? a1 : a2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// return (Arrays.compare(a1, a2) == 0) ? a1 : a2;</span></span><br><span class="line">            <span class="keyword">return</span> (Arrays.toString(a1).compareTo(Arrays.toString(a2)) == <span class="number">0</span>) ? a1 : a2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] searchInsert(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span> || a &lt; arr[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; a &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayAppend(arr, a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left + <span class="number">1</span> != right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (arr[mid] &gt; a)&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] result = Arrays.copyOfRange(arr, <span class="number">0</span>, right+<span class="number">1</span>);</span><br><span class="line">            result[result.length - <span class="number">1</span>] = a;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        result[result.length - <span class="number">1</span>] = a;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">7</span>,&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(LIS(arr)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大正方形">(0911)最大正方形</h3>
<ul>
<li><p>初始化，<code>DP = mat</code></p></li>
<li><p>遍历，<code>包含第[i][j]个结点的最大正方形</code></p></li>
<li><p>状态转移方程:</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if mat[i][j] &#x3D;&#x3D; 1&#123;</span><br><span class="line">    dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NowCoder_BiggestSquare</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] mat = &#123; &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span> &#125;, &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span> &#125;, &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span> &#125;,</span><br><span class="line">                &#123; <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span> &#125; &#125;;</span><br><span class="line">        System.out.println(solve(mat));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    max = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(dp[i][j], max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            System.out.println(Arrays.toString(dp[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max * max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Dynamic Programming (DP)</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Mining Lec1</title>
    <url>/2020/09/12/Data-Mining-Lec1/</url>
    <content><![CDATA[<h3 id="课程信息-ieore4540">课程信息 IEORE4540</h3>
<p>Lecturer: <a href="https://research.google/people/KrzysztofChoromanski/">Krzysztof Choromanski</a></p>
<ul>
<li>Krzysztof Choromanski works on several aspects of machine learning and robotics. His current research interests include reinforcement learning and randomized methods such as nonlinear embeddings based on structured random feature maps and quasi-Monte-Carlo methods. He was also working on online nonparametric clustering for massive high-dimensional streams. Krzysztof is an author of several nonlinear embedding mechanisms based on structured matrices that can be used to speed up: neural network computations, kernel methods applying random feature maps, convex optimization solvers, quantization and soft clustering methods as well as several LSH-based algorithms. With his background in structural graph theory, he is also interested in applying graph theory and other combinatorial methods in machine learning.</li>
</ul>
<p>Contact: <a href="KMC2178@columbia.edu">KMC2178@columbia.edu</a>|<a href="CHOROMANSKI1@gmail.com">CHOROMANSKI1@gmail.com</a>|<a href="KCHORO@google.com">KCHORO@google.com</a></p>
<h3 id="提要">提要</h3>
<p>第一节课主要涉及几类核方法(Kernel)，random feature map，和MSE</p>
<h3 id="笔记正文">笔记正文</h3>
<div class="pdfobject-container" data-target="./Lec1.pdf" data-height="1000px"></div>
<h3 id="补充-核函数-kernels-与-svm">补充： 核函数 Kernels 与 SVM</h3>
<p><a href="https://www.youtube.com/watch?v=mTyT-oHoivA">cs229 Lecture 12.4 — Support Vector Machines | (Kernels-I) — [ Machine Learning | Andrew Ng]</a></p>
<h4 id="kernels">Kernels</h4>
<p>Kernel is aka similarity function. We set up <code>landmarks</code>: <span class="math inline">\(l_1, l_2, l_3\)</span> and we wanna know the similarity between our input <span class="math inline">\(x\)</span> and these landmarks.</p>
<p>Gaussian kernel <span class="math inline">\(K_{Gauss}\)</span> is</p>
<p><span class="math display">\[f_i = similarity(x, l^{(i)}) = exp(-\frac{||x-l^{(i)}||^2}{2\sigma^2})\]</span></p>
<p><span class="math inline">\(\sigma\)</span> is one hyperparameter which decides the shape of "contour graph" -- aka scaling the similarity</p>
<p>Then we are gonna use similarities <span class="math inline">\(f_i\)</span> to classify <span class="math inline">\(y\)</span>.</p>
<p>Predict <span class="math inline">\(y=1\)</span> if</p>
<p><span class="math display">\[\theta_0 + \theta_1f_1 + \theta_2f_2 + \theta_3f_3 \geq 0\]</span></p>
<p>Here, <span class="math inline">\(\theta\)</span> s are weights. If we wanna know whether <span class="math inline">\(x\)</span> is close to landmarks <span class="math inline">\(l_1\)</span> and <span class="math inline">\(l_2\)</span>, we could set <span class="math inline">\(\theta_1 = 1, \theta_2 = 1, \theta_3 = 0\)</span>.</p>
<h4 id="svm-with-kernels">SVM with Kernels</h4>
<p>Given <span class="math inline">\((x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), ..., (x^{(m)}, y^{(m)})\)</span></p>
<p>we choose <code>landmarks</code> <span class="math inline">\(l^{(i)} = x^{(i)}\)</span></p>
<p><span class="math display">\[f_1 = similarity(x, l^{(1)})\]</span> <span class="math display">\[f_2 = similarity(x, l^{(2)})\]</span> <span class="math display">\[......\]</span> <span class="math display">\[f_m = similarity(x, l^{(m)})\]</span></p>
<p>Define <span class="math inline">\(f\)</span></p>
<p><span class="math display">\[f = \begin{bmatrix}f_0\\f_1\\f_2\\...\\f_m\end{bmatrix}\]</span> where <span class="math inline">\(f_0 = 1\)</span></p>
<p>for training example <span class="math display">\[f^{(i)} = \begin{bmatrix}f_0^{(i)}\\f_1^{(i)}\\f_2^{(i)}\\...\\f_m^{(i)}\end{bmatrix}\]</span></p>
<p><span class="math inline">\(f \in \large{R}^{m+1}\)</span>, predict <span class="math inline">\(y=1\)</span> if <span class="math inline">\(\theta^{T}f \geq 0\)</span></p>
<p><span class="math inline">\(\theta \in \large{R}^{m+1}\)</span></p>
<p>When training, the objective function changes w.r.t <span class="math inline">\(f\)</span></p>
<p><span class="math display">\[\min_{\theta} C\sum_{i=1}^{m}{y^{(i)}cost_1{(\theta^Tf^{(i)})} +  (1-y^{(i)})cost_0{(\theta^Tf^{(i)})}} + \frac{1}{2} \sum_{j=1}^{m}{\theta_j^2}\]</span></p>
<h3 id="wiki-kernel-method">Wiki: <a href="https://en.wikipedia.org/wiki/Kernel_method">Kernel Method</a></h3>
<p>使用内核函数，在高维隐式特征空间中操作，而无需计算该空间中数据的坐标，而是在特征空间中计算内积。</p>
<p>基于实例： 内核方法基于实例学习，并非训练一些固定数量的参数, 而是记住 <span class="math inline">\(i\)</span>-th training example <span class="math inline">\((\mathbf {x}_{i},\mathbf {y}_{i})\)</span> 并学习到对应的权重 <span class="math inline">\(w_{i}\)</span>.</p>
<p><span class="math display">\[\therefore w:\mathbf R^m, x:\mathbf R^m\]</span></p>
<h3 id="总结一下遇到的各种核函数"><a href="https://blog.csdn.net/wsj998689aa/article/details/47027365">总结一下遇到的各种核函数</a></h3>
<p>PCA在原始空间中的数学模型 <span class="math display">\[XX^Tw_i=\lambda_iw_i\]</span> 在高维空间中 <span class="math display">\[\Phi(X)\Phi(X)^Tw_i^{\Phi} = \lambda_iw_i^{\Phi}\]</span> 基向量 <span class="math inline">\(w_i^{\Phi}\)</span> 用训练样本线性表示(上文提到 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(x\)</span> 关系,都在 <span class="math inline">\(N\times d\)</span> 维空间) <span class="math display">\[w_i^{\Phi} = \sum_{k=1}^{N}{\alpha_k\Phi(x_k)} = \Phi(X)\alpha_i \]</span> 代入 <span class="math display">\[\Phi(X)\Phi(X)^T\Phi(X)\alpha_i = \lambda_i\Phi(X)\alpha_i\]</span> <span class="math display">\[\Phi(X)^T\Phi(X)\Phi(X)^T\Phi(X)\alpha_i = \lambda_i\Phi(X)^T\Phi(X)\alpha_i\]</span> 某种<strong>核函数</strong>满足 <span class="math display">\[ k(x_i, x_j) = \Phi(x_i)^T\Phi(x_j) \]</span> 矩阵化表示 <span class="math display">\[ K(X,Y) = \Phi(X)^T\Phi(X) \]</span> 则 <span class="math display">\[ K^2\alpha_i = \lambda_iK\alpha_i \]</span> 可以看见高维映射被抹掉了。</p>
<p>那么核函数具有什么样的性质？</p>
<h3 id="mercers-theorem"><a href="https://en.wikipedia.org/wiki/Mercer%27s_theorem">Mercer's theorem</a></h3>
<p>Mercer's theorem: 任何半正定的函数都可以作为核函数。(充分不必要)</p>
<p><span class="math display">\[X = (x_1,x_2,...x_n)\]</span></p>
<p>我们定义矩阵的元素 <span class="math display">\[a_{ij} = f(x_i,x_j)\]</span></p>
<p>如果这个 <span class="math inline">\(n*n\)</span> 的矩阵是半正定的，那么 <span class="math inline">\(f(x_i,x_j)\)</span> 就称为半正定的函数。</p>
<h3 id="常见核函数">常见核函数</h3>
<h4 id="linear-kernel">Linear Kernel</h4>
<p><span class="math display">\[ k(x,y) = x^Ty \]</span></p>
<h4 id="gaussian-kernel">Gaussian Kernel</h4>
<p><span class="math display">\[ k_{Gauss}(x,y) = \exp(-\frac{||x-y||^2}{2\sigma^2}) \]</span></p>
<h4 id="exponential-kernel">Exponential Kernel</h4>
<p>将高斯核的 L2 距离调整为 L1 距离</p>
<p><span class="math display">\[ k(x,y) = \exp(-\frac{||x-y||}{2\sigma^2}) \]</span></p>
<h4 id="laplacian-kernel">Laplacian Kernel</h4>
<p>等价于指数核</p>
<p><span class="math display">\[ k(x,y) = \exp(-\frac{||x-y||}{\sigma}) \]</span></p>
<h4 id="softmax-kernel">Softmax Kernel</h4>
<p><span class="math display">\[ K_{SM}(x,y) = e^{x^Ty} \]</span> <span class="math display">\[ = e^{\frac{||x||^2}{2}}  e^{\frac{||y||^2}{2}}  K_{Gauss}(x,y) \]</span></p>
<h4 id="angular-kernel">Angular Kernel</h4>
<p><span class="math display">\[ K_{Ang}(x,y) = 1 - \frac{2\theta_{x,y}}{\pi} \]</span></p>
<h3 id="feature-map-phi-的结构">feature map <span class="math inline">\(\Phi\)</span> 的结构</h3>
<p><span class="math display">\[ \Phi(x) = \frac{1}{\sqrt{m}} \begin{bmatrix}f_1(w_1^Tx),...,f_1(w_m^Tx)\\...\\f_l(w_1^Tx),...,f_l(w_m^Tx)\end{bmatrix}^T \]</span></p>
]]></content>
      <categories>
        <category>Data Mining</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Tutorial -- Wordcount in Spark</title>
    <url>/2020/09/15/Spark-Tutorial-Wordcount-in-Spark/</url>
    <content><![CDATA[<h2 id="cs246---colab-1-wordcount-in-spark">CS246 - Colab 1 Wordcount in Spark</h2>
<div class="pdfobject-container" data-target="./CS246Colab1.pdf" data-height="1000px"></div>
]]></content>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2020/09/18/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h3 id="集合的所有子集">(0918) 集合的所有子集</h3>
<p>题目描述</p>
<p>现在有一个没有重复元素的整数集合S，求S的所有子集</p>
<p>注意： - 你给出的子集中的元素必须按升序排列 - 给出的解集中不能出现重复的元素 - 例如：如果S=[1,2,3], 给出的解集应为： [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []]</p>
<p>解法： - 递归，集合每增加一个新元素，先前所有非空子集 + 这些非空子集加入新元素生成的新子集 + 该元素本身形成的集合 - 边界条件：空集合需要包含一个空子集 - 注意：递归时非空子集的运算屏蔽空子集 (continue) ，但每次返回时增加一个空子集。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NowCoder_subsets</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 集合的所有子集 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] S) &#123;</span><br><span class="line">        <span class="comment">// 包含空子集</span></span><br><span class="line">        <span class="keyword">if</span> (S.length == <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; empty = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            result.add(empty);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] S_m1 = Arrays.copyOfRange(S, <span class="number">0</span>, S.length - <span class="number">1</span>);</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result_m1 = subsets(S_m1);</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;Integer&gt; subset_m1 : result_m1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (subset_m1.size() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 空子集暂时不管</span></span><br><span class="line">            result.add(subset_m1); <span class="comment">// 之前的也要加上</span></span><br><span class="line">            ArrayList&lt;Integer&gt; subset = (ArrayList&lt;Integer&gt;) subset_m1.clone();</span><br><span class="line">            subset.add(S[S.length - <span class="number">1</span>]);</span><br><span class="line">            Collections.sort(subset);</span><br><span class="line">            result.add(subset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加最后一位的一元子集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; lastDigit = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        lastDigit.add(S[S.length - <span class="number">1</span>]);</span><br><span class="line">        result.add(lastDigit);</span><br><span class="line">        <span class="comment">// 加空集</span></span><br><span class="line">        ArrayList&lt;Integer&gt; empty = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(empty);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] S = &#123; <span class="number">1</span> &#125;;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subset = subsets(S);</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;Integer&gt; i : subset)</span><br><span class="line">            System.out.println(Arrays.toString(i.toArray()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树层序遍历">(0919) 二叉树层序遍历</h3>
<p>题目描述 给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）例如：给定的二叉树是{3,9,20,#,#,15,7},该二叉树层序遍历的结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">[3],</span><br><span class="line">[9,20],</span><br><span class="line">[15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NowCoder_LevelOrder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ArrayList&lt;Integer&gt; width = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            width.add(root.val);</span><br><span class="line">            result.add(width);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = treeDepth(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            result.add(ithlevel(root, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定二叉树深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(treeDepth(root.left), treeDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归确定二叉树每层width的所有结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">ithlevel</span><span class="params">(TreeNode root, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; width = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> width;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            width.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> width;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; leftwidth = ithlevel(root.left, i - <span class="number">1</span>);</span><br><span class="line">            ArrayList&lt;Integer&gt; rightwidth = ithlevel(root.right, i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : rightwidth) &#123;</span><br><span class="line">                leftwidth.add(val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> leftwidth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Data-Mining-Lec2</title>
    <url>/2020/09/16/Data-Mining-Lec2/</url>
    <content><![CDATA[<h2 id="lemmas">(09/20)Lemmas</h2>
<h3 id="eulers-formula-欧拉公式">Euler's formula 欧拉公式</h3>
<p><span class="math display">\[ e^{ix} = \cos{x} + i\sin{x} \]</span></p>
<h3 id="fourier-transform-傅里叶变换">Fourier transform 傅里叶变换</h3>
<p><a href="https://www.zhihu.com/question/19714540/answer/1119070975">如何理解傅里叶变换公式？ - 苗华栋的回答 - 知乎</a></p>
<h4 id="三角函数正交性">三角函数正交性</h4>
<p><span class="math display">\[ \sum_{-\pi}^{\pi}{\sin{mx}\sin{nx} dx} = \begin{cases} 0, m\neq n \\ \pi, m = n \end{cases} \]</span></p>
<p>证明： 积化和差，周期内积分。</p>
<h4 id="正余弦函数组成正交基时域-to-频域">正余弦函数组成正交基，时域 <span class="math inline">\(\to\)</span> 频域</h4>
<p><span class="math display">\[ 1, cos(x), sin(x), cos(2x), sin(2x), ... cos(nx), sin(nx) \]</span></p>
<h4 id="公式实值函数时">公式(实值函数时)</h4>
<p>频率表示为 <span class="math inline">\(2 \pi f\)</span></p>
<p><span class="math display">\[ s_{N}(x) = \frac{a_0}{2} + \sum_{n = 1}^{\infty}{[a_n\cos{(2 \pi fnx)} + b_n\sin{(2 \pi fnx)}]} \]</span></p>
<p><span class="math display">\[a_{n} = A_{n}\sin{(\phi_{n})}, b_{n} = A_{n}\cos{(\phi_{n})}\]</span></p>
<p><span class="math inline">\(\frac{a_0}{2}\)</span> 对应直流份量，任何连续周期信号都可以由一组适当的正弦曲线组合而成。（非周期信号的周期认为是无穷大）</p>
<p>一般地，可以用正交性求 <span class="math inline">\(a_{n}\)</span> 和 <span class="math inline">\(b_{n}\)</span>。</p>
<p><span class="math display">\[ a_{n} = 2f \int_{x_0}^{x_0 + \frac{1}{f}}{s(x)\cdot \cos{(2\pi fnx)}dx} \]</span> <span class="math display">\[ b_{n} = 2f \int_{x_0}^{x_0 + \frac{1}{f}}{s(x)\cdot \sin{(2\pi fnx)}dx} \]</span></p>
<h1 id="shift-invariant-kernels">Shift-invariant Kernels</h1>
<h2 id="random-fourier-featuresrff">Random Fourier Features(RFF)</h2>
<p><a href="https://people.eecs.berkeley.edu/~brecht/papers/07.rah.rec.nips.pdf">Random Features for Large-Scale Kernel Machines</a></p>
<p><span class="math display">\[ k(x,y) = &lt;\phi(x), \phi(y)&gt; = z(x)&#39;z(y) \]</span></p>
<p>Gaussian: <span class="math display">\[ e^{-\frac{||\Delta||^2}{2}} \]</span> Shift-invariant: x + z, y + z, delta remains, Radial basis function (<strong>RBF</strong>) kernel</p>
<p>The only thing that matters is the length of <span class="math inline">\(\Delta\)</span></p>
<p>Random Feature Map function of Gaussian: <span class="math display">\[ \Phi(x) = \frac{1}{\sqrt{m}} (\sin(w_1^Tx),...\sin(w_m^Tx), \cos(w_1^Tx),...\cos(w_m^Tx)) \]</span></p>
<h3 id="bochners-theorem"><strong>Bochner's Theorem</strong></h3>
<p>A continuous kernel <span class="math inline">\(k(x, y) = f(x − y)\)</span> on <span class="math inline">\(R^d\)</span> is positive definite if and only if <span class="math inline">\(k(δ)\)</span> is the Fourier transform of a non-negative measure. Here ignore the imaginery part <span class="math inline">\(\sin\)</span>.</p>
<p><span class="math display">\[ K: R^d \times R^d \to R \]</span> <span class="math display">\[ K(x,y) = f(x-y) = f(z) = \int_{R^d}{p(w)cos(w^Tz)dw}=E_{w \sim \Omega}[cos(w^Tz)]\]</span> where <span class="math inline">\(p\)</span> is the probability distribution corresponding to <span class="math inline">\(k\)</span></p>
<p>Example, if <span class="math inline">\(K\)</span> is Gaussian then <span class="math inline">\(\Omega = N(0, I_d)\)</span></p>
<p>Since we have the form of expectation, we run <strong>simulations</strong> or say <strong>[Monte Carlo]</strong> to estimate shift-invariant kernels.</p>
<ul>
<li>choose your number of random samples</li>
<li>Sample <span class="math inline">\(w_1, ..., w_m \sim{iid} \Omega\)</span></li>
<li>Estimate: <span class="math inline">\(K(x,y)\)</span> as <span class="math inline">\(\hat{K}(x,y)\)</span></li>
<li><span class="math inline">\(\hat{K}(x,y)\)</span>: the mean of the sum, unbiased estimation of the original kernel.</li>
</ul>
<p><span class="math display">\[ \hat{K}(x,y) = \frac{1}{m} \sum_{i=1}^{m}{cos(w_i^Tz)} = \frac{1}{m} \sum_{i=1}^m{X_i} \]</span></p>
<ul>
<li><span class="math inline">\(X_i\)</span> is iid and bounded, strong concentration results.</li>
<li><span class="math inline">\(\hat{K}(x,y) = \phi(x)^T\phi(y)\)</span> ? How we can disentangle <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> from <span class="math inline">\(z\)</span>? cosine identities.</li>
</ul>
<p><span class="math display">\[ \hat{K}(x,y) = \frac{1}{m} \sum_{i=1}^{m}{cos(w_i^Tx - w_i^Ty)} \]</span> <span class="math display">\[ = \frac{1}{m} \sum_{i=1}^{m}{[cos(w_i^Tx)cos(w_i^Ty) + sin(w_i^Tx)sin(w_i^Ty)]} \]</span></p>
<ul>
<li><p>Disentangled!</p></li>
<li><p>Define</p></li>
</ul>
<p><span class="math display">\[ \phi(x) = \frac{1}{\sqrt{m}} \begin{bmatrix}\cos(w_1^Ty)\\...\\\cos(w_m^Ty)\\\sin(w_1^Ty)\\...\\\sin(w_m^Ty) \end{bmatrix} \]</span> <span class="math display">\[ \hat{K}(x,y) = \phi(x)^T\phi(y) \]</span></p>
<ul>
<li>Now <span class="math inline">\(w\)</span> can be distributions other than Gaussian: <span class="math inline">\(w_i \sim iid \Omega\)</span></li>
</ul>
<h3 id="attention-model---softmax-kernel-and-random-feature-map">Attention Model - Softmax kernel and random feature map</h3>
<p>Sequence. We wanna find out similarity between embeddings(tokens) and how they attend to each other. We use kernels to calculate this attention.</p>
<p>Construct a huge matrix (len*len).</p>
<p>One most popular similarity model is <strong>softmax attention</strong></p>
<p>Softmax kernel: <span class="math display">\[ K_{SM}(x,y) = e^{x^Ty}\]</span></p>
<p>Relationship between gaussian kernel and softmax kernel? Just by expanding <span class="math display">\[ K_{Gauss}(x,y) = K_{SM}(x,y) e^{-\frac{||x||^2}{2}} e^{-\frac{||y||^2}{2}} \]</span></p>
<p><a href="https://arxiv.org/pdf/2006.03555.pdf">Masked Language Modeling for Proteins via LinearlyScalable Long-Context Transformers</a> This one covers the relationship between two kernels.</p>
<p><span class="math display">\[ SM(x,y) = e^{\frac{||x||^2}{2}}K_{Gauss}(x,y)e^{\frac{||y||^2}{2}} \]</span></p>
<p>From above, <span class="math inline">\(K(x,y) = E[\hat{K}(x,y)]\)</span>, <span class="math display">\[ K_{Gauss}(x,y) = E[\phi(x)^T\phi(y)] \]</span></p>
<p><span class="math display">\[ \hat{SM}(x,y) = e^{\frac{||x||^2}{2}}\phi(x)^T\phi(y)e^{\frac{||y||^2}{2}} \]</span> <span class="math display">\[ = (e^{\frac{||x||^2}{2}}\phi(x))^T(e^{\frac{||y||^2}{2}}\phi(y)) \]</span> <span class="math display">\[ \phi_{SM}(x) = e^{\frac{||x||^2}{2}}\phi_{Gauss}(x) = e^{\frac{||x||^2}{2}} \frac{1}{\sqrt{m}} \begin{bmatrix}\cos(w_1^Ty)\\...\\\cos(w_m^Ty)\\\sin(w_1^Ty)\\...\\\sin(w_m^Ty) \end{bmatrix} \]</span> <span class="math display">\[ SM(x,y) = E[\hat{SM}(x,y)] = E[\phi_{SM}(x)^T\phi_{SM}(y)] \]</span></p>
<h1 id="orthogonal-random-featuresorf">Orthogonal random features(ORF)</h1>
<p><a href="https://papers.nips.cc/paper/6246-orthogonal-random-features.pdf">https://papers.nips.cc/paper/6246-orthogonal-random-features.pdf)</a></p>
<h2 id="standard-setting-for-constructing-random-features-via-gaussian-projections">Standard setting for constructing random features via Gaussian projections</h2>
<p><strong>IID</strong>: <span class="math inline">\(w_1, ..., w_m \sim{iid} \Omega\)</span>. Sampling independently from canonical multivariate gaussian distribution.</p>
<h2 id="constructing-orthogonal-random-features">Constructing orthogonal random features</h2>
<h3 id="definition">Definition</h3>
<p><strong>ORT</strong>: for variance reduction, <span class="math inline">\(w_1, ..., w_m\)</span> sampled in a way that,</p>
<ul>
<li><p>marginal distributions are still the same as for IID, i.e. <span class="math inline">\(w_1 \sim{N(0,I_d)}\)</span></p></li>
<li><p>different samples <span class="math inline">\(w_i\)</span> are conditioned to <strong>be exactly and definitely orthogonal</strong>, i.e. <span class="math inline">\(w_i^Tw_j = 0\)</span> for <span class="math inline">\(i\neq j\)</span></p></li>
</ul>
<p>They are not independent(if i.i.d, although <span class="math inline">\(E=0\)</span>, <span class="math inline">\(Var\neq 0\)</span>). Rows have to be <strong>deterministic</strong> in the Linear Space.</p>
<h3 id="how-we-obtain-this-orthogonality">How we obtain this orthogonality?</h3>
<ol type="1">
<li>Create Gaussian matrix <span class="math inline">\(G\in \R^{m\times d}\)</span> with entries (a.k.a <span class="math inline">\(w_i\)</span>) taken independently at random from scalar Gaussian distribution N(0,1).</li>
<li><strong>Gram-Schmidt</strong> orthogonalize <span class="math inline">\(G\)</span>. After this rows of G are exactly orthogonal and of unit L2-norm.</li>
<li>Renormalize each row of the resulting matrix by multiplying via random variable token from <span class="math inline">\(\chi(d)\)</span> distribution. The renormalization for each row can be same or different.</li>
<li><strong>Note</strong>: the procedures are feasible only when <span class="math inline">\(m \leq d\)</span></li>
</ol>
<h4 id="gram-schmidt-orthogonalization-施密特正交化"><strong>Gram-schmidt orthogonalization 施密特正交化</strong></h4>
<p>Gram–Schmidt process is a method for orthonormalizing a set of vectors in an inner product space, most commonly the Euclidean space Rn equipped with the standard inner product. The Gram–Schmidt process takes a finite, linearly independent set S = {v1, ..., vk} for <strong>k ≤ n</strong> and generates an orthogonal set S′ = {u1, ..., uk} that spans the same k-dimensional subspace of Rn as S.</p>
<p>Whenever move to the next row, subtract the projection from previous rows.</p>
<h2 id="complexity-analysis">Complexity analysis</h2>
<p>D: random features, d: dimensionality</p>
<p>ORF is as expensive as RFF.</p>
<ul>
<li>ORF:
<ul>
<li>generating <span class="math inline">\(d\times d\)</span> orthogonal matrix, <span class="math inline">\(O(d^3)\)</span> time and <span class="math inline">\(O(d^2)\)</span> space</li>
<li>computing the transformation, <span class="math inline">\(O(d^2)\)</span> time and space</li>
</ul></li>
</ul>
<h2 id="structured-orf-sorf-...to-be-continued">Structured ORF (SORF) ...to be continued</h2>
]]></content>
      <categories>
        <category>Data Mining</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
